<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HandEvaluator</name>
    </assembly>
    <members>
        <member name="T:HoldemHand.Hand">
            <example>
            <code>
            using System;
            using System.Collections.Generic;
            using System.Text;
            using HoldemHand;
            
            // Simple example of using the Holdem.Hand class
            class Program
            {
                static void Main(string[] args)
                {
                    // initialize board
                    string board = "2d kh qh 3h qc";
                    // Create a mask with AKs plus board
                    Hand h1 = new Hand("ad kd", board);
                    // Create a mask with 23 unsuited plus board
                    Hand h2 = new Hand("2h 3d", board);
            
                    // Find stronger mask and print results
                    if (h1 > h2)
                    {
                        Console.WriteLine("{0} greater than \n\t{1}", h1.Description, h2.Description);
                    }
                    else
                    {
                        Console.WriteLine("{0} less than or equal \n\t{1}", h1.Description, h2.Description);
                    }
                }
            }
            </code>
            </example>
            
            <summary>
            Represents a Texas Holdem Hand
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.DefaultTimeDuration">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.HandStrength(System.UInt64,System.UInt64)">
            <summary>
            The classic HandStrengh Calculation from page 21 of Aaron Davidson's
            Masters Thesis.
            </summary>
            <param name="pocket">Pocket cards</param>
            <param name="board">Current Board</param>
            <returns>Hand strength as a percentage of hands won.</returns>
        </member>
        <member name="M:HoldemHand.Hand.HandStrength(System.String,System.String,System.Int32,System.Double)">
            <summary>
            A HandStrength function that accounts for multiple opponents. This method uses the
            Monte Carlo menthod to calculate a value. It takes surprisingly little time to get
            good results. A duration of 0.01 seconds (10mS) returns good results, and a duration of 0.1 (100mS) returns
            even better results.
            </summary>
            <param name="pocketquery">pocket mask query</param>
            <param name="board">current board</param>
            <param name="NOpponnents">the number of opponents (must be 1-9)</param>
            <param name="duration">time in seconds to perform this calculation</param>
            <returns>returns percentage of hands won</returns>
        </member>
        <member name="M:HoldemHand.Hand.HandStrength(System.UInt64,System.UInt64,System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="pocket"></param>
            <param name="board"></param>
            <param name="NOpponnents"></param>
            <param name="duration"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.StraightDrawCount(System.UInt64,System.UInt64)">
            <summary>
            The method returns the number of straight draws that are possible for the current mask.      
            </summary>
            <param name="mask">Current Hand</param>
            <param name="dead">Dead cards</param>
            <returns>The number of straight draws for this mask type.</returns>
        </member>
        <member name="M:HoldemHand.Hand.StraightDrawCount(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            The method returns the number of straight draws that are possible for the player and board configuration.   
            This method filters the results so only player hand improvements are counted.
            </summary>
            <param name="player">Two card mask making up the players pocket cards</param>
            <param name="board">The community cards</param>  
            <param name="dead">Dead cards</param>  
            <returns>The number of straight draws for this mask type.</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsOpenEndedStraightDraw(System.UInt64,System.UInt64)">
            <summary>
            Returns true if the combined mask is an open ended straight draw.
            </summary>
            <param name="mask">Players pocket cards mask</param>
            <param name="dead">Community card mask</param>
            <returns>Returns true if the combined mask is an open ended straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsOpenEndedStraightDraw(System.String,System.String)">
            <summary>
            Returns true if the mask is an open ended straight draw.
            </summary>
            <param name="mask">Players pocket cards mask</param>
            <param name="dead">Community card mask</param>
            <returns>Returns true if the combined mask is an open ended straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsOpenEndedStraightDraw(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns true if the combined mask is an open ended straight draw. Only straight possiblities that
            improve the player's mask are considered in this method.
            </summary>
            <param name="pocket">Players pocket cards mask</param>
            <param name="board">Community card mask</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if the combined mask is an open ended straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsGutShotStraightDraw(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Return true if the combined cards contain a gut shot straight.
            </summary>
            <param name="pocket">Players pocket cards mask</param>
            <param name="board">Community card mask</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true of the combined mask is a gut shot straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsGutShotStraightDraw(System.UInt64,System.UInt64)">
            <summary>
            Return true if the combined cards contain a gut shot straight.
            </summary>
            <param name="mask">Current mask</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true of the combined mask is a gut shot straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsGutShotStraightDraw(System.String,System.String)">
            <summary>
            Return true if the combined cards contain a gut shot straight.
            </summary>
            <param name="mask">Current mask</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true of the combined mask is a gut shot straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsStraightDraw(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns true if the passed mask only needs one card to make a straight.
            Note that the pocket cards must contains at least one card in the 
            combined straight.
            </summary>
            <param name="pocket">Players pocket mask</param>
            <param name="board">Community board</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if mask has a straight draw.</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsStraightDraw(System.UInt64,System.UInt64)">
            <summary>
            Returns true if the passed mask only needs one card to make a straight.
            Note that the pocket cards must contains at least one card in the 
            combined straight.
            </summary>
            <param name="mask">Current Hand</param>
            <param name="dead">Dead Cards</param>
            <returns>Returns true if mask has a straight draw.</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsStraightDraw(System.String,System.String)">
            <summary>
            Returns true if the passed mask only needs one card to make a straight.
            Note that the pocket cards must contains at least one card in the 
            combined straight.
            </summary>
            <param name="mask">Current Hand</param>
            <param name="dead">Dead Cards</param>
            <returns>Returns true if mask has a straight draw.</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsStraightDraw(System.String,System.String,System.String)">
            <summary>
            Returns true if the passed mask only needs one card to make a straight.
            </summary>
            <param name="pocket">Players pocket mask</param>
            <param name="board">Community board</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if mask has a straight draw.</returns>
        </member>
        <member name="M:HoldemHand.Hand.CountContiguous(System.UInt64,System.UInt64)">
            <summary>
            Returns the count of adjacent cards
            </summary>
            <param name="pocket">Players pocket cards mask</param>
            <param name="board">Community card mask</param>
            <returns>Return the number of contigous cards</returns>
        </member>
        <member name="M:HoldemHand.Hand.CountContiguous(System.UInt64)">
            <summary>
            Returns the count of adjacent cards
            </summary>
            <param name="mask">Current Hand</param>
            <returns>Return the number of contigous cards</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsGutShotStraightDraw(System.String,System.String,System.String)">
            <summary>
            Return true if the combined cards contain a gut shot straight.
            </summary>
            <param name="pocket">Players pocket cards</param>
            <param name="board">Community cards</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true of the combined mask is a gut shot straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsOpenEndedStraightDraw(System.String,System.String,System.String)">
            <summary>
            Returns true if the combined mask is an open ended straight draw.
            </summary>
            <param name="pocket">Players pocket cards</param>
            <param name="board">Community cards</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if the combined mask is an open ended straight draw</returns>
        </member>
        <member name="M:HoldemHand.Hand.FlushDrawCount(System.UInt64,System.UInt64)">
            <summary>
            Counts the number of hands that are a flush with one more drawn card.
            </summary>
            <param name="mask">Hand</param>
            <param name="dead">Cards not allowed to be drawn</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.FlushDrawCount(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Counts the number of hands that are a flush with one more drawn card. However, 
            Flush hands that only improve the board are not considered.
            </summary>
            <param name="player">Players two card hand</param>
            <param name="board">Board cards</param>
            <param name="dead">Dead cards</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.IsFlushDraw(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns true if there are 4 cards of the same suit.
            </summary>
            <param name="pocket">Players pocket cards mask</param>
            <param name="board">Community card mask</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if there are 4 cards of the same suit</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsFlushDraw(System.UInt64,System.UInt64)">
            <summary>
            Returns true if the hand is a flush draw.
            </summary>
            <param name="mask">Cards</param>
            <param name="dead">Dead cards</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.IsFlushDraw(System.String,System.String,System.String)">
            <summary>
            Returns true if there are 4 cards of the same suit.
            </summary>
            <param name="pocket">Players pocket cards</param>
            <param name="board">Community cards</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if there are 4 cards of the same suit</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsBackdoorFlushDraw(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns true if there are three cards of the same suit. 
            The pocket cards must have at least one card in that suit.
            </summary>
            <param name="pocket">Players pocket cards mask</param>
            <param name="board">Community card mask</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if there are three cards of the same suit</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsBackdoorFlushDraw(System.String,System.String,System.String)">
            <summary>
            Returns true if there are three cards of the same suit. 
            The pocket cards must have at least one card in that suit.
            </summary>
            <param name="pocket">Players pocket cards</param>
            <param name="board">Community cards</param>
            <param name="dead">Dead cards</param>
            <returns>Returns true if there are three cards of the same suit</returns>
        </member>
        <member name="M:HoldemHand.Hand.DrawCount(System.UInt64,System.UInt64,System.UInt64,HoldemHand.Hand.HandTypes)">
            <summary>
            The method returns the number of draws that are possible for the
            specified HandType. This method only returns the counts that improve the 
            player's mask rather than just the board. Because of this subtle distinction,
            DrawCount(player, board, dead, type) doesn't necessarily return the same value as
            DrawCount(player | board, dead, type).
            </summary>
            <param name="player">Two card mask making up the players pocket cards</param>
            <param name="board">The community cards</param>
            <param name="dead">Dead cards</param>
            <param name="type">They type of mask to count draws for.</param>
            <returns>The number of draws for this mask type.</returns>
        </member>
        <member name="M:HoldemHand.Hand.DrawCount(System.UInt64,System.UInt64,HoldemHand.Hand.HandTypes)">
            <summary>
            The method returns the number of draws that are possible for the
            specified HandType. Note that DrawCount(pocket, board, dead, type) is not
            necessarily the same as DrawCount(pocket | board, dead, type). 
            
            This method returns all possible draws that are the same as the requested type.
            </summary>
            <param name="mask">Hand</param>
            <param name="dead">Dead cards</param>
            <param name="type">They type of mask to count draws for.</param>
            <returns>The number of draws for this mask type.</returns>
        </member>
        <member name="M:HoldemHand.Hand.DrawCount(System.String,System.String,System.String,HoldemHand.Hand.HandTypes)">
            <summary>
            The method returns the number of draws that are possible for the
            specified HandType.
            </summary>
            <param name="player">Two card mask making up the players pocket cards</param>
            <param name="board">The community cards</param>
            <param name="dead">Dead cards</param>
            <param name="type">They type of mask to count draws for.</param>
            <returns>The number of draws for this mask type.</returns>
        </member>
        <member name="M:HoldemHand.Hand.UniqueHands(System.UInt64,System.Int32)">
            <summary>
            This method returns the number of unique mask values that can 
            be made with ncards, where all of the hands contain the shared cards.
            </summary>
            <param name="shared">Cards required in all of the hands</param>
            <param name="ncards">The number of cards in the mask</param>
            <returns>The total number of unique mask values</returns>
        </member>
        <member name="M:HoldemHand.Hand.HandDistance(System.UInt64,System.UInt64)">
            <summary>
            This method returns the mask distance from the best possible
            mask given this board (no draws are considered). The value 0 is the 
            best possible mask. The value 1 is the next best mask and so on.
            </summary>
            <param name="pocket">The players pocket mask</param>
            <param name="board">The board mask</param>
            <returns>An integer representing the distance from the best possible mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.OutsDiscounted(System.UInt64,System.UInt64,System.UInt64[])">
            <summary>
            Returns the number of discouted outs possible with the next card.
            
            Players pocket cards
            The board (must contain either 3 or 4 cards)
            A list of zero or more opponent cards.
            The count of the number of single cards that improve the current hand applying the following discouting rules:
            1) Drawing to a pair must use an over card (ie a card higher than all those on the board)
            2) Drawing to 2 pair / pairing your hand is discounted if the board is paired (ie your 2 pair drawing deat to trips)
            3) Drawing to a hand lower than a flush must not make a 3 suited board or the board be 3 suited.
            4) Drawing to a hand lower than a stright, the flop must not be 3card connected or on the turn
            allow a straight to be made with only 1 pocket card or the out make a straight using only 1 card.
            
            Function provided by Matt Baker.
            </summary>
            <param name="player">Players pocket hand</param>
            <param name="board">Board cards so far</param>
            <param name="opponents">Opponents pocket hands</param>
            <returns>Number of outs</returns>
        </member>
        <member name="M:HoldemHand.Hand.OutsMaskDiscounted(System.UInt64,System.UInt64,System.UInt64[])">
            <summary>
            
            Creates a Hand mask with the cards that will improve the specified players hand
            against a list of opponents or if no opponents are list just the cards that improve the 
            players current hand. 
            
            This implements the concept of 'discounted outs'. That is outs that will improve the
            players hand, but not potentially improve an opponents hand to an even better one. For
            example drawing to a straight that could end up loosing to a flush.
            
            Please note that this only looks at single cards that improve the hand and will not specifically
            look at runner-runner possiblities.
            
            Players pocket cards
            The board (must contain either 3 or 4 cards)
            A list of zero or more opponent pocket cards
            A mask of all of the cards that improve the hand applying the following discouting rules: 
            1) Drawing to a pair must use an over card (ie a card higher than all those on the board)
            2) Drawing to 2 pair / pairing your hand is discounted if the board is paired (ie your 2 pair drawing deat to trips)
            3) Drawing to a hand lower than a flush must not make a 3 suited board or the board be 3 suited.
            4) Drawing to a hand lower than a stright, the flop must not be 3card connected or on the turn
            allow a straight to be made with only 1 pocket card or the out make a straight using only 1 card. 
            
            
            Function provided by Matt Baker.
            </summary>
            <param name="player">Players pocket hand</param>
            <param name="board">Board mask</param>
            <param name="opponents">Opponent pocket hand</param>
            <returns>Mask of cards that are probable outs.</returns>
        </member>
        <member name="M:HoldemHand.Hand.Outs(System.String,System.String,System.String[])">
            <summary>
            Returns the number of outs possible with the next card. Note that cards that only
            help the board will be ignored.
            </summary>
            <param name="player">Players pocket cards</param>
            <param name="board">The board (must contain either 3 or 4 cards)</param>
            <param name="opponents">A list of zero or more opponent cards.</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.OutCards(System.String,System.String,System.String[])">
            <summary>
            Returns a string of the possible outs for the next card. Note that cards that only
            help the board will be ignored.
            </summary>
            <param name="player">Player pocket card string</param>
            <param name="board">Board card string</param>
            <param name="opponents">Opponent card strings</param>
            <returns>String containing the cards that will improve the players mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.Outs(System.UInt64,System.UInt64,System.UInt64[])">
            <summary>
            Returns the number of outs possible with the next card.
            </summary>
            <param name="player">Players pocket cards</param>
            <param name="board">The board (must contain either 3 or 4 cards)</param>
            <param name="opponents">A list of zero or more opponent cards.</param>
            <returns>The count of the number of single cards that improve the current mask.</returns>
        </member>
        <member name="M:HoldemHand.Hand.OutsMask(System.UInt64,System.UInt64,System.UInt64[])">
            <summary>
            Creates a Hand mask with the cards that will improve the specified players mask
            against a list of opponents or if no opponents are list just the cards that improve the 
            players current had.
            
            Please note that this only looks at single cards that improve the mask and will not specifically
            look at runner-runner possiblities.
            </summary>
            <param name="player">Players pocket cards</param>
            <param name="board">The board (must contain either 3 or 4 cards)</param>
            <param name="opponents">A list of zero or more opponent pocket cards</param>
            <returns>A mask of all of the cards taht improve the mask.</returns>
        </member>
        <member name="M:HoldemHand.Hand.OutsMaskEx(System.UInt64,System.UInt64,System.UInt64)">
             <summary>
             Creates a Hand mask with the cards that will improve the specified players mask.
            
             Please note that this only looks at single cards that improve the mask and will not specifically
             look at runner-runner possiblities.
             
             This version of outs contributed by Matt Baker
             </summary>
             <param name="player">Players pocket cards</param>
             <param name="board">The board (must contain either 3 or 4 cards)</param>
             <param name="dead">Dead cards</param>
             <returns>A mask of all of the cards taht improve the mask.</returns>
        </member>
        <member name="M:HoldemHand.Hand.OutsMaskEx(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="pocket"></param>
            <param name="board"></param>
            <param name="dead"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.OutsEx(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            
            </summary>
            <param name="pocket"></param>
            <param name="board"></param>
            <param name="dead"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.OutsEx(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="pocket"></param>
            <param name="board"></param>
            <param name="dead"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.IsSuited(System.UInt64)">
            <summary>
            This function returns true if the cards in the mask are all one suit. This method
            calculates the results. Because of the equivelent call in PocketHands is preferred
            because it uses a lookup table and is faster. This function remains to allow for automated
            testing.
            </summary>
            <param name="mask">mask to check for "suited-ness"</param>
            <returns>true if all hands are of the same suit, false otherwise.</returns>
        </member>
        <member name="M:HoldemHand.Hand.IsConnected(System.UInt64)">
            <summary>
            Returns true if the cards in the two card mask are connected. This method
            calculates the results. Because of that equivelent call in PocketHands is preferred
            because it uses a lookup table and is faster. This function remains to allow for automated
            testing.
            </summary>
            <param name="mask">the mask to check</param>
            <returns>true of all of the cards are next to each other.</returns>
        </member>
        <member name="M:HoldemHand.Hand.GapCount(System.UInt64)">
            <summary>
            Counts the number of empty space between adjacent cards. 0 means connected, 1 means a gap
            of one, 2 means a gap of two and 3 means a gap of three. This method
            calculates the results. Because of that equivelent call in PocketHands is preferred
            because it uses a lookup table and is faster. This function remains to allow for automated
            testing.
            </summary>
            <param name="mask">two card mask mask</param>
            <returns>number of spaces between two cards</returns>
        </member>
        <member name="M:HoldemHand.Hand.DetailedOddsWithMultiplePlayers(System.String,System.String,System.UInt64,System.Int32,System.Double[]@,System.Double[]@,System.Int32)">
            <summary>
            Cacluates the approxamate odds that each player and opponent mask
            type has to win. This method uses Monte Carlo Analysis to determine
            a results. The quality of the result will depend on the number of trials.
            </summary>
            <param name="pocket">Players Hand</param>
            <param name="board">Current Board</param>
            <param name="dead">Dead Cards</param>
            <param name="playerCount">the number of players in the mask.</param>
            <param name="playerodds">The returned odds array for the player</param>
            <param name="oppodds">The returned odds array for the opponents</param>
            <param name="trials">The number of simulations to run.</param>
        </member>
        <member name="M:HoldemHand.Hand.DetailedOddsWithMultiplePlayers(System.String,System.String,System.UInt64,System.Int32,System.Double[]@,System.Double[]@,System.Double)">
            <summary>
            Cacluates the approxamate odds that each player and opponent mask
            type has to win. This method uses Monte Carlo Analysis to determine
            a results. The quality of the result will depend on the amount of time
            allowed for the simulation.
            </summary>
            <param name="pocket">Players Hand</param>
            <param name="board">Current Board</param>
            <param name="dead">Dead Cards</param>
            <param name="playerCount">the number of players in the mask.</param>
            <param name="playerodds">The returned odds array for the player</param>
            <param name="oppodds">The returned odds array for the opponents</param>
            <param name="duration">The time allowed to run the simulation</param>
        </member>
        <member name="M:HoldemHand.Hand.DetailedOddsWithMultiplePlayers(System.UInt64,System.UInt64,System.UInt64,System.Int32,System.Double[]@,System.Double[]@,System.Int32)">
            <summary>
            Cacluates the approxamate odds that each player and opponent mask
            type has to win. This method uses Monte Carlo Analysis to determine
            a results. The quality of the result will depend on the number of trials.
            </summary>
            <param name="pocket">Players Hand</param>
            <param name="board">Current Board</param>
            <param name="dead">Dead Cards</param>
            <param name="playerCount">the number of players in the mask.</param>
            <param name="playerodds">The returned odds array for the player</param>
            <param name="oppodds">The returned odds array for the opponents</param>
            <param name="trials">The number of simulations to run.</param>
        </member>
        <member name="M:HoldemHand.Hand.DetailedOddsWithMultiplePlayers(System.UInt64,System.UInt64,System.UInt64,System.Int32,System.Double[]@,System.Double[]@,System.Double)">
            <summary>
            Cacluates the approxamate odds that each player and opponent mask
            type has to win. This method uses Monte Carlo Analysis to determine
            a results. The quality of the result will depend on the amount of time
            allowed for the simulation.
            </summary>
            <param name="pocket">Players Hand</param>
            <param name="board">Current Board</param>
            <param name="dead">Dead Cards</param>
            <param name="playerCount">the number of players in the mask.</param>
            <param name="playerodds">The returned odds array for the player</param>
            <param name="oppodds">The returned odds array for the opponents</param>
            <param name="duration">The time allowed to run the simulation</param>
        </member>
        <member name="M:HoldemHand.Hand.HandWinOdds(System.UInt64[],System.UInt64[],System.UInt64,System.Double[]@,System.Double[]@)">
            <summary>
            
            </summary>
            <param name="ourcards"></param>
            <param name="oppcards"></param>
            <param name="board"></param>
            <param name="player"></param>
            <param name="opponent"></param>
            <returns>True means approximate results</returns>
        </member>
        <member name="M:HoldemHand.Hand.HandWinOdds(System.UInt64,System.UInt64,System.Double[]@,System.Double[]@)">
            <summary>
            Given a set of pocket cards and a set of board cards this function returns the odds of winning or tying for a player and a random opponent.
            </summary>
            <param name="ourcards">Pocket mask for the mask.</param>
            <param name="board">Board mask for mask</param>
            <param name="player">Player odds as doubles</param>
            <param name="opponent">Opponent odds as doubles</param>
        </member>
        <member name="M:HoldemHand.Hand.HandWinOdds(System.String,System.String,System.Double[]@,System.Double[]@)">
            <summary>
            Given a set of pocket cards and a set of board cards this function returns the odds of winning or tying for a player and a random opponent.
            </summary>
            <param name="pocketcards">Pocket cards in ASCII</param>
            <param name="boardcards">Board cards in ASCII</param>
            <param name="player">Player odds as doubles</param>
            <param name="opponent">Opponent odds as doubles</param>
        </member>
        <member name="M:HoldemHand.Hand.HandWinOdds(System.UInt64,System.UInt64,System.Double[]@,System.Double[]@,System.Int32,System.Double)">
            <summary>
            This method calculates the probablity of a player winning with specific hands and 
            opponents winning with specific hands.
            </summary>
            <param name="ourcards">pocket card mask</param>
            <param name="board">board cards mask</param>
            <param name="player">player win odds</param>
            <param name="opponent">opponent(s) win odds</param>
            <param name="NOpponents">The number of opponents</param>
            <param name="duration">The amount of time in seconds to calculate samples</param>
        </member>
        <member name="M:HoldemHand.Hand.HandWinOdds(System.String,System.String,System.Double[]@,System.Double[]@,System.Int32,System.Double)">
            <summary>
            This method calculates the probablity of a player winning with specific hands and 
            opponents winning with specific hands.
            </summary>
            <param name="ourcards">pocket cards</param>
            <param name="board">board cards</param>
            <param name="player">player win odds</param>
            <param name="opponent">opponent(s) win odds</param>
            <param name="NOpponents">The number of opponents</param>
            <param name="duration">The amount of time in seconds to calculate samples</param>
        </member>
        <member name="M:HoldemHand.Hand.HandWinOdds(System.String[],System.String,System.String,System.Int64[],System.Int64[],System.Int64[],System.Int64@)">
            <summary>
            Used to calculate the wining information about each players mask. This function enumerates all 
            possible remaining hands and tallies win, tie and losses for each player. This function typically takes
            well less than a second regardless of the number of players.
            </summary>
            <param name="pockets">Array of pocket mask string, one for each player</param>
            <param name="board">the board cards</param>
            <param name="dead">the dead cards</param>
            <param name="wins">An array of win tallies, one for each player</param>
            <param name="ties">An array of tie tallies, one for each player</param>
            <param name="losses">An array of losses tallies, one for each player</param>
            <param name="totalHands">The total number of hands enumarated.</param>
        </member>
        <member name="M:HoldemHand.Hand.HandPotential(System.UInt64,System.UInt64,System.Double@,System.Double@)">
            <summary>
            Returns the normalized, positive and negative potential of the current mask. This funciton
            is described in Aaron Davidson's masters thesis on page 23.
            </summary>
            <param name="pocket">Hold Cards</param>
            <param name="board">Community cards</param>
            <param name="ppot">Positive Potential</param>
            <param name="npot">Negative Potential</param>
        </member>
        <member name="M:HoldemHand.Hand.HandPotential(System.UInt64,System.UInt64,System.Double@,System.Double@,System.Int32,System.Double)">
            <summary>
            This method is similar to the HandPotential algorithm described in Aaron Davidson's
            masters thesis, however if differs in several significant ways. First, it makes the calculation
            while accounting for one or more opponents. Second, it uses the Monte Carlo technique to get 
            answers in a reasonable amount of time (a duration of 0.1 seems to give reasonable results). And
            finally, the results are not normalized; the positive and negative potential is the actual odds of improvement
            or worsening of a mask.
            </summary>
            <param name="pocket">Players pocket card mask</param>
            <param name="board">The current board mask</param>
            <param name="ppot">The resultant positive potential</param>
            <param name="npot">The resultant negative potential</param>
            <param name="NOpponents">The number of opponents</param>
            <param name="duration">The length of time (in seconds) to spend on this calculation</param>
        </member>
        <member name="M:HoldemHand.Hand.HandPotential(System.String,System.String,System.Double@,System.Double@,System.Int32,System.Double)">
            <summary>
            This method is similar to the HandPotential algorithm described in Aaron Davidson's
            masters thesis, however if differs in several significant ways. First, it makes the calculation
            while accounting for one or more opponents. Second, it uses the Monte Carlo technique to get 
            answers in a reasonable amount of time (a duration of 0.1 seems to give reasonable results). And
            finally, the results are not normalized; the positive and negative potential is the actual odds of improvement
            or worsening of a mask.
            </summary>
            <param name="pockethand">Players pocket card query string</param>
            <param name="boardhand">The current board string</param>
            <param name="ppot">The resultant positive potential</param>
            <param name="npot">The resultant negative potential</param>
            <param name="NOpponents">The number of opponents</param>
            <param name="duration">The length of time (in seconds) to spend on this calculation</param>
        </member>
        <member name="M:HoldemHand.Hand.HandPlayerMultiOpponentOdds(System.UInt64,System.UInt64,System.Int32,System.Double,System.Double[]@,System.Double[]@)">
            <summary>
            
            </summary>
            <param name="ourcards"></param>
            <param name="board"></param>
            <param name="numOpponents"></param>
            <param name="duration"></param>
            <param name="player"></param>
            <param name="opponent"></param>
        </member>
        <member name="M:HoldemHand.Hand.WinOdds(System.String,System.String,System.UInt64,System.Int32)">
             <summary>
             This method returns the approximate odd for the players mask winning against multiple opponents.
             This uses a default time duration of 0.25S (or 250mS) for the time allotment for Monte Carlo analysis.
             </summary>
             <param name="pocket">The pocket mask of the player.</param>
             <param name="board">The current board cards</param>
             <param name="dead">Dead cards</param>
             <param name="numOpponents">The number of oppoents 1-9 are legal values</param>
             <returns>The approximate odds of winning the passed mask against the number of opponents specified.</returns>
             <example>
             <code>
             using System;
             using HoldemHand;
            
             namespace ConsoleApplication1
             {
                class Program
                {
                    static void Main(string[] args)
                    {
                        // Outputs approximately the following: 50.82%
                        Console.WriteLine("{0:#.00}%", Hand.WinOdds("As Ks", "Ts Qs 4h", 0UL, 5) * 100.0);
                    }
                }
             }
             </code>
             </example>
        </member>
        <member name="M:HoldemHand.Hand.WinOdds(System.String,System.String,System.Int32)">
            <summary>
            This method returns the approximate odd for the players mask winning against multiple opponents.
            This uses a default time duration of 0.25S (or 250mS) for the time allotment for Monte Carlo analysis.
            </summary>
            <param name="pocket">The pocket mask of the player.</param>
            <param name="board">The current board cards</param>
            <param name="numOpponents">The number of oppoents 1-9 are legal values</param>
            <returns>The approximate odds of winning the passed mask against the number of opponents specified.</returns>
        </member>
        <member name="M:HoldemHand.Hand.WinOdds(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            This method returns the exact odds of the specified mask mask
            winning against an average player. It's reasonably fast because it
            uses a lookup table when possible.
            </summary>
            <param name="pocket">The pocket mask</param>
            <param name="board">The board mask</param>
            <param name="dead">Dead cards</param>
            <returns>The Win odds</returns>
        </member>
        <member name="M:HoldemHand.Hand.WinOdds(System.UInt64,System.UInt64,System.UInt64,System.Int32)">
            <summary>
            This method returns the approximate odd for the players mask winning against multiple opponents.
            This uses a default time duration of 0.1S (or 100mS) for the time allotment for Monte Carlo analysis.
            </summary>
            <param name="pocket">The pocket mask of the player.</param>
            <param name="board">The current board cards</param>
            <param name="dead">Dead cards</param>
            <param name="numOpponents">The number of oppoents 1-9 are legal values</param>
            <returns>The approximate odds of winning the passed mask against the number of opponents specified.</returns>
            <example>
            <code>
            using System;
            using HoldemHand;
            
            namespace ConsoleApplication1
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        ulong pocket = Hand.ParseHand("As Ks");
                        ulong board = Hand.ParseHand("Ac 2d 8c");
                        // Outputs approximately the following: 49.33%
                        Console.WriteLine("{0:#.00}%", Hand.WinOdds(pocket, board, 5) * 100.0);
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.WinOdds(System.UInt64,System.UInt64,System.UInt64,System.Int32,System.Double)">
            <summary>
            This method returns the approximate odd for the players mask winning against multiple opponents.
            </summary>
            <param name="pocket">The pocket mask of the player.</param>
            <param name="board">The current board cards</param>
            <param name="dead">Dead cards</param>
            <param name="numOpponents">The approximate odds of winning the passed mask against the number of opponents specified.</param>
            <param name="duration">The period of time (in seconds) to run trials. On my 2.8Ghz laptop 0.1 seconds seems adequate.</param>
            <returns>The approximate odds of winning the passed mask against the number of opponents specified.</returns>
            <example>
            <code>
            using System;
            using HoldemHand;
            
            namespace ConsoleApplication1
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        ulong pocket = Hand.ParseHand("As Ks");
                        ulong board = Hand.ParseHand("Ac 2d 8c");
                        // Outputs approximately the following: 49.77%
                        Console.WriteLine("{0:#.00}%", Hand.WinOdds(pocket, board, 5, 1.5) * 100.0);
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.WinOdds(System.String,System.String,System.String,System.Int32,System.Double)">
            <summary>
            This method returns the approximate odd for the players mask winning against multiple opponents.
            </summary>
            <param name="pocketquery">The pocket mask of the player.</param>
            <param name="boardhand">The current board cards</param>
            <param name="deadcards">dead cards</param>
            <param name="numOpponents">The approximate odds of winning the passed mask against the number of opponents specified.</param>
            <param name="duration">The period of time (in seconds) to run trials. On my 2.8Ghz laptop 0.1 seconds seems adequate.</param>
            <returns>The approximate odds of winning the passed mask against the number of opponents specified.</returns>
            <example>
            <code>
            using System;
            using HoldemHand;
            
            namespace ConsoleApplication1
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        // Outputs approximately the following: 31.06%
                        Console.WriteLine("{0:#.00}%", Hand.WinOdds("AKs", "", 5, 1.5) * 100.0);
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="F:HoldemHand.Hand.contiguousCountTable">
            <summary>
            Contains the count of the maximum number of contiguous bits
            in a 13 bit word (where bits 1 and bits 13 can be considered
            adjacent)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PreCalcPlayerOdds">
            <summary>
            This table is used by HandPlayerOpponentOdds and contains the odds of each type of 
            mask occuring against a random player when the board is currently empty. This calculation
            normally takes about 5 minutes, so the values are precalculated to save time.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PreCalcOppOdds">
            This table is used by HandPlayerOpponentOdds and contains the odds of each type of 
            mask occuring for a random player when the board is currently empty. This calculation
            normally takes about 5 minutes, so the values are precalculated to save time.
        </member>
        <member name="T:HoldemHand.Hand.HandTypes">
            <summary>
            Possible types of hands in a texas holdem game.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.HighCard">
            <summary>
            Only a high card
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.Pair">
            <summary>
            One Pair
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.TwoPair">
            <summary>
            Two Pair
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.Trips">
            <summary>
            Three of a kind (Trips)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.Straight">
            <summary>
            Straight
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.Flush">
            <summary>
            Flush
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.FullHouse">
            <summary>
            FullHouse
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.FourOfAKind">
            <summary>
            Four of a kind
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.HandTypes.StraightFlush">
            <summary>
            Straight Flush
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Hearts">
            <summary>
            Represents the suit - Hearts
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Diamonds">
            <summary>
            Represents the suit - Diamonds
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Clubs">
            <summary>
            Represents the suit - Clubs
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Spades">
            <summary>
            Represents the suit - Spades
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank2">
            <summary>
            Rank of a card with a value of two.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank3">
            <summary>
            Rank of a card with a value of three.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank4">
            <summary>
            Rank of a card with a value of four.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank5">
            <summary>
            Rank of a card with a value of five.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank6">
            <summary>
            Rank of a card with a value of six.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank7">
            <summary>
            Rank of a card with a value of seven.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank8">
            <summary>
            Rank of a card with a value of eight.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.Rank9">
            <summary>
            Rank of a card with a value of nine.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.RankTen">
            <summary>
            Rank of a card with a value of ten.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.RankJack">
            <summary>
            Rank of a card showing a Jack.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.RankQueen">
            <summary>
            Rank of a card showing a Queen.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.RankKing">
            <summary>
            Rank of a card showing a King.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.RankAce">
            <summary>
            Rank of a card showing an Ace.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.CardJoker">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.NumberOfCards">
            <summary>
            The total number of cards in a deck
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.NCardsWJoker">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_SHIFT">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.TOP_CARD_SHIFT">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.TOP_CARD_MASK">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.SECOND_CARD_SHIFT">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.SECOND_CARD_MASK">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.THIRD_CARD_SHIFT">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.FOURTH_CARD_SHIFT">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.FIFTH_CARD_SHIFT">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.FIFTH_CARD_MASK">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.CARD_WIDTH">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.CARD_MASK">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.handmask">
            <summary>
            Hand mask for the current card set
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.pocket">
            <summary>
            Contains string representing the pocket cards
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.board">
            <summary>
            Contains a string representing the board (common cards)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.handval">
            <summary>
            The value of the current had. This value allows hands to be 
            compared using a normal arithmitic compare function.
            </summary>
        </member>
        <member name="M:HoldemHand.Hand.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:HoldemHand.Hand.#ctor(System.String,System.String)">
            <example>
            <code>
            using System;
            using System.Collections.Generic;
            using System.Text;
            using HoldemHand;
            
            // Simple example of using the Holdem.Hand class
            class Program
            {
                static void Main(string[] args)
                {
                    // initialize board
                    string board = "2d kh qh 3h qc";
                    // Create a mask with AKs plus board
                    Hand h1 = new Hand("ad kd", board);
                    // Create a mask with 23 unsuited plus board
                    Hand h2 = new Hand("2h 3d", board);
            
                    // Find stronger mask and print results
                    if (h1 > h2)
                    {
                        Console.WriteLine("{0} greater than \n\t{1}", h1.Description, h2.Description);
                    }
                    else
                    {
                        Console.WriteLine("{0} less than or equal \n\t{1}", h1.Description, h2.Description);
                    }
                }
            }
            </code>
            </example>
            <summary>
            Constructor
            </summary>
            <param name="pocket">Pocket Cards</param>
            <param name="board">Board</param>
        </member>
        <member name="M:HoldemHand.Hand.ValidateHand(System.String)">
            <summary>
            This function takes a string representing a full or partial holdem mask 
            and validates that the text represents valid cards and that no card is
            duplicated.
            </summary>
            <param name="hand">mask to validate</param>
            <returns>true of a valid mask, false otherwise</returns>
        </member>
        <member name="M:HoldemHand.Hand.ValidateHand(System.String,System.String)">
            <summary>
            This function takes a string representing pocket cards and a board and then 
            validates that the text represents a valid mask.
            </summary>
            <param name="pocket">Pocket cards as a string</param>
            <param name="board">Board cards as a string</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.ParseHand(System.String)">
            <example>
            <code>
             // Takes an ascii seven card mask and prints out a 
             // value description. For example: "ad kd 2d kh qh 3h qc" would
             // output "Two pair, King's and Queen's with a Ace for a kicker"
             static void PrintDescription(string mask)
             {
                 // Parse mask into a mask mask
                 ulong handmask = Hand.ParseHand(mask);
             
                 // Convert mask mask into a compariable mask value.
                 uint handval = Hand.Evaluate(handmask, 7);
             
                 // Print a description of the mask.
                 Console.WriteLine("Hand: {0}", Hand.DescriptionFromHandValue(handval));
             }
            </code>
            </example>
            <summary>
            Parses an string description of a mask and returns a mask mask.
            </summary>
            <param name="mask">string descripton of a mask</param>
            <returns>a mask mask representing the mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.ParseHand(System.String,System.Int32@)">
            <summary>
            Parse Hand.
            </summary>
            <param name="hand">Hand string</param>
            <param name="cards">Cards found</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.ParseHand(System.String,System.String,System.Int32@)">
            <summary>
            This static method parses the passed pocket cards and board and produces
            a card mask.
            </summary>
            <param name="pocket">ASCII string representing pocket cards</param>
            <param name="board">ASCII string representing board</param>
            <param name="cards">Number of cards represented in mask</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.ParseCard(System.String)">
            <summary>
            Reads an string definition of a card and returns the Card value.
            </summary>
            <param name="card">card string</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.NextCard(System.String,System.Int32@)">
            <summary>
            Parses Card strings (internal)
            </summary>
            <param name="cards">string containing mask definition</param>
            <param name="index">iterator into card string</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.CardRank(System.Int32)">
            <summary>
            Given a card value, returns it's rank
            </summary>
            <param name="card">card value</param>
            <returns>returns rank</returns>
        </member>
        <member name="M:HoldemHand.Hand.CardSuit(System.Int32)">
            <summary>
            Given a card value, returns it's suit
            </summary>
            <param name="card">Card value</param>
            <returns>suit</returns>
        </member>
        <member name="M:HoldemHand.Hand.DescriptionFromHandValueInternal(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.DescriptionFromMask(System.UInt64)">
            <summary>
            Evaluates a hand and returns a descriptive string.
            </summary>
            <param name="cards">Card mask</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.DescriptionFromHand(System.String)">
            <summary>
            Takes an string describing a mask and returns the description.
            </summary>
            <param name="mask">the string describing the mask</param>
            <returns>Returns a description string</returns>
            <example>
            <code>
            // Print a description of the mask.
            Console.WriteLine("Hand: {0}", Hand.DescriptionFromHand("ad kd 2d kh qh 3h qc"));
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.UpdateHandMask">
            <summary>
            Updates handmask and handval, called when card strings change
            </summary>
        </member>
        <member name="M:HoldemHand.Hand.ToString">
            <summary>
            Returns the string representing the mask.
            </summary>
            <returns></returns>
        </member>
        <member name="P:HoldemHand.Hand.MaskValue">
            <summary>
            Returns mask mask value
            </summary>
        </member>
        <member name="P:HoldemHand.Hand.PocketMask">
            <summary>
            Represents the Mask of the Pocket cards for this instance
            of Hand
            </summary>
        </member>
        <member name="P:HoldemHand.Hand.BoardMask">
            <summary>
            Represents the Mask of the Board cards for this instance
            of Hand
            </summary>
        </member>
        <member name="P:HoldemHand.Hand.PocketCards">
            <summary>
            Returns/Sets pocket card string
            </summary>
        </member>
        <member name="P:HoldemHand.Hand.Board">
            <summary>
            Returns/Sets board card string
            </summary>
        </member>
        <member name="P:HoldemHand.Hand.HandValue">
            <summary>
            Returns/Sets the mask value. This value may be used
            to compare one mask to another using standard numeric 
            compares.
            </summary>
        </member>
        <member name="P:HoldemHand.Hand.Description">
            <summary>
            Returns a textual description of the current mask
            </summary>
        </member>
        <member name="P:HoldemHand.Hand.HandTypeValue">
            <summary>
            Returns the current mask type.
            </summary>
        </member>
        <member name="M:HoldemHand.Hand.Mask(System.Int32)">
            <summary>
            This is a fast way to look up the index mask. 
            </summary>
            <param name="index">index of mask</param>
            <returns>mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.HandType(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.TopCard(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.SECOND_CARD(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.THIRD_CARD(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.FOURTH_CARD(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.FIFTH_CARD(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.HANDTYPE_VALUE(HoldemHand.Hand.HandTypes)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.TOP_CARD_VALUE(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.SECOND_CARD_VALUE(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.THIRD_CARD_VALUE(System.UInt32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.CardMask(System.UInt64,System.Int32)">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.MaskToString(System.UInt64)">
            <summary>
            Turns a card mask into the equivalent human readable string.
            </summary>
            <param name="mask">mask to convert</param>
            <returns>human readable string that is equivalent to the mask represented by the mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.EvaluateType(System.UInt64)">
            <summary>
            Evaluates the card mask and returns the type of mask it is. This function is
            faster (but provides less information) than Evaluate or Evaluate.
            </summary>
            <param name="mask">card mask</param>
            <returns>A HandTypes value</returns>
            <example>
            <code>
            public static long ValidateEnumerate5()
            {
                int[] handtypes = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
                int count = 0;
            
                // Iterate through all possible 5 card hands
                foreach (ulong mask in Hands(5))
                {
                    handtypes[(int)Hand.EvaluateType(mask)]++;
                    count++;
                }
            
                // Validate results.
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.HighCard] == 1302540);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.Pair] == 1098240);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.TwoPair] == 123552);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.Trips] == 54912);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.Straight] == 10200);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.Flush] == 5108);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.FullHouse] == 3744);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.FourOfAKind] == 624);
                System.Diagnostics.Debug.Assert(handtypes[(int)HandTypes.StraightFlush] == 40);
                System.Diagnostics.Debug.Assert(count == 2598960);
                return count;
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.EvaluateType(System.UInt64,System.Int32)">
            <summary>
             This function is faster (but provides less information) than Evaluate or Evaluate.
            </summary>
            <param name="mask">card mask</param>
            <param name="cards">number of cards in mask</param>
            <returns>HandType enum that describes the rank of the mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.Evaluate(System.UInt64)">
            <summary>
            Evaluates a mask (passed as a mask mask) and returns a mask value.
            A mask value can be compared against another mask value to
            determine which has the higher value.
            </summary>
            <param name="cards">mask mask</param>
            <returns>Hand Value bit field</returns>
        </member>
        <member name="M:HoldemHand.Hand.Evaluate(System.String)">
            <summary>
            Evaluates a mask (passed as a string) and returns a mask value.
            A mask value can be compared against another mask value to
            determine which has the higher value.
            </summary>
            <param name="mask">mask string</param>
            <returns>Hnad Value bit field</returns>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_STRAIGHTFLUSH">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_STRAIGHT">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_FLUSH">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_FULLHOUSE">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_FOUR_OF_A_KIND">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_TRIPS">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_TWOPAIR">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_PAIR">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HANDTYPE_VALUE_HIGHCARD">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.SPADE_OFFSET">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.CLUB_OFFSET">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.DIAMOND_OFFSET">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.HEART_OFFSET">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.Evaluate(System.UInt64,System.Int32)">
            <summary>
            Evaluates a mask (passed as a mask mask) and returns a mask value.
            A mask value can be compared against another mask value to
            determine which has the higher value.
            </summary>
            <param name="cards">mask mask</param>
            <param name="nCards">number of cards in the mask</param>
            <returns>mask value</returns>
            <example>
            <code>
            // Takes an ascii seven card mask and prints out a 
            // value description. For example: "ad kd 2d kh qh 3h qc" would
            // output "Two pair, King's and Queen's with a Ace for a kicker"
            static void PrintDescription(string mask)
            {
                // Parse mask into a mask mask
                ulong handmask = Hand.ParseHand(mask);
            
                // Convert mask mask into a compariable mask value.
                uint handval = Hand.Evaluate(handmask, 7);
            
                // Print a description of the mask.
                Console.WriteLine("Hand: {0}", Hand.DescriptionFromHandValue(handval));
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.CompareTo(System.Object)">
            <summary>
            Used to compare one mask to another. This method allows
            normal compare functions to work as expected with a mask.
            </summary>
            <param name="obj">object to compare against</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.Equals(System.Object)">
            <summary>
            Test for equality
            </summary>
            <param name="obj"></param>
            <returns>returns true if equal, false otherwise</returns>
        </member>
        <member name="M:HoldemHand.Hand.GetHashCode">
            <summary>
            Returns hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:HoldemHand.Hand.op_Equality(HoldemHand.Hand,HoldemHand.Hand)">
            <summary>
            Test for equality
            </summary>
            <param name="op1">left side object</param>
            <param name="op2">right side object</param>
            <returns>returns true if equal, false otherwise</returns>
            <example>
            <code>
            // These two hands are equal because the five best cards
            // in both hands are the same.
            Hand h1 = new Hand("ac as", "4d 5d 6c 7c 8d");
            Hand h2 = new Hand("td js", "4d 5d 6c 7c 8d");
            
            if (h1 == h2)
            {
                Console.WriteLine("Hands are equal");
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.op_Inequality(HoldemHand.Hand,HoldemHand.Hand)">
            <summary>
            Test for inequality.
            </summary>
            <param name="op1">left side object</param>
            <param name="op2">right side object</param>
            <returns>returns true if not equal, false otherwise</returns>
            <example>
            <code>
            Hand h1 = new Hand("ac as", "4d 5d 6c 7c 8d");
            Hand h2 = new Hand("td 9s", "4d 5d 6c 7c 8d");
            
            if (h1 != h2)
            {
                Console.WriteLine("Hand h2 is a higher straight");
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.op_GreaterThan(HoldemHand.Hand,HoldemHand.Hand)">
            <summary>
            Test that the left side is greater than the right side.
            </summary>
            <param name="op1">left side</param>
            <param name="op2">right side</param>
            <returns>returns true of the left item is greater than the right item</returns>
            <example>
            <code>
            Hand h1 = new Hand("ac as", "4d 5d 6c 7c 8d");
            Hand h2 = new Hand("td 9s", "4d 5d 6c 7c 8d");
            
            if (h2 > h1)
            {
                Console.WriteLine("Hand h2 is a higher straight");
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.op_GreaterThanOrEqual(HoldemHand.Hand,HoldemHand.Hand)">
            <summary>
            Test that the left side is greater or equal than the right side.
            </summary>
            <param name="op1">left side</param>
            <param name="op2">right side</param>
            <returns>returns true of the left item is greater or equal than the right item</returns>
            <example>
            <code>
            Hand h1 = new Hand("ac as", "4d 5d 6c 7c 8d");
            Hand h2 = new Hand("td 9s", "4d 5d 6c 7c 8d");
            
            if (h2 >= h1)
            {
                Console.WriteLine("Hand h2 is a higher straight");
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.op_LessThan(HoldemHand.Hand,HoldemHand.Hand)">
            <summary>
            Test that the left side is less than the right side.
            </summary>
            <param name="op1">left side</param>
            <param name="op2">right side</param>
            <returns>returns true if the left item is less than the right item.</returns>
        </member>
        <member name="M:HoldemHand.Hand.op_LessThanOrEqual(HoldemHand.Hand,HoldemHand.Hand)">
            <summary>
            Test that the left side is less than or equal to the right side.
            </summary>
            <param name="op1">left side</param>
            <param name="op2">right side</param>
            <returns>returns true if the left item is less than or equal to the right item.</returns>
        </member>
        <member name="M:HoldemHand.Hand.BitCount(System.UInt64)">
            <summary>
            Count Bits. Optimized for cards so only works with 52 bits.
            </summary>
            <param name="bitField"></param>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.Hand.nBitsAndStrTable">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.nBitsTable">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.straightTable">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.topFiveCardsTable">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.topCardTable">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.CardMasksTable">
            <summary>
            This table is equivalent to 1UL left shifted by the index.
            The lookup is faster than the left shift operator.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.CardMasksTableSize">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.CardTable">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.ranktbl">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.suittbl">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.rankchar">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.suitchar">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.TwoCardMaskTable">
            <summary>
            1326 ulong cards masks for all hold cards.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.TwoCardMaskTableSize">
            <exclude/>
        </member>
        <member name="F:HoldemHand.Hand.Pocket169Table">
            <summary>
            The 1326 possible pocket cards ordered by the 169 unique holdem combinations. The
            index is equivalent to the number value of Hand.PocketPairType.
            </summary>
        </member>
        <member name="T:HoldemHand.Hand.PocketHand169Enum">
            <summary>
            An enumeration value for each of the 169 possible types of pocket cards.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.None">
            <summary>
            Not a PocketHand169Enum
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketAA">
            <summary>
            Represents a pair of Aces (Pocket Rockets)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketKK">
            <summary>
            Represents a pair of Kings (Cowboys)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQQ">
            <summary>
            Represents a pair of Queens (Ladies)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJJ">
            <summary>
            Represents a pair of Jacks (Fish hooks)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketTT">
            <summary>
            Represents a pair of Tens (Rin Tin Tin)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket99">
            <summary>
            Represents a pair of Nines (Gretzky)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket88">
            <summary>
            Represents a pair of Eights (Snowmen)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket77">
            <summary>
            Represents a pair of Sevens (Hockey Sticks)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket66">
            <summary>
            Represents a pair of Sixes (Route 66)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket55">
            <summary>
            Represents a pair of Fives (Speed Limit)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket44">
            <summary>
            Represents a pair of Fours (Sailboats)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket33">
            <summary>
            Represents a pair of Threes (Crabs)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket22">
            <summary>
            Represents a pair of Twos (Ducks)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketAKs">
            <summary>
            Represents Ace/King Suited (Big Slick)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketAKo">
            <summary>
            Represents Ace/King offsuit (Big Slick)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketAQs">
            <summary>
            Represents Ace/Queen Suited (Little Slick)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketAQo">
            <summary>
            Represents Ace/Queen offsuit (Little Slick)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketAJs">
            <summary>
            Represents Ace/Jack suited (Blackjack)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketAJo">
            <summary>
            Represents Ace/Jack offsuit (Blackjack)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketATs">
            <summary>
            Represents Ace/Ten suited (Johnny Moss)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketATo">
            <summary>
            Represents Ace/Ten offsuit (Johnny Moss)
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA9s">
            <summary>
            Represents Ace/Nine suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA9o">
            <summary>
            Represents Ace/Nine offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA8s">
            <summary>
            Represents Ace/Eight suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA8o">
            <summary>
            Represents Ace/Eight offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA7s">
            <summary>
            Represents Ace/seven suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA7o">
            <summary>
            Represents Ace/seven offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA6s">
            <summary>
            Represents Ace/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA6o">
            <summary>
            Represents Ace/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA5s">
            <summary>
            Represents Ace/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA5o">
            <summary>
            Represents Ace/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA4s">
            <summary>
            Represents Ace/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA4o">
            <summary>
            Represents Ace/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA3s">
            <summary>
            Represents Ace/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA3o">
            <summary>
            Represents Ace/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA2s">
            <summary>
            Represents Ace/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketA2o">
            <summary>
            Represents Ace/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketKQs">
            <summary>
            Represents King/Queen suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketKQo">
            <summary>
            Represents King/Queen offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketKJs">
            <summary>
            Represents King/Jack suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketKJo">
            <summary>
            Represents King/Jack offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketKTs">
            <summary>
            Represents King/Ten suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketKTo">
            <summary>
            Represents King/Ten offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK9s">
            <summary>
            Represents King/Nine suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK9o">
            <summary>
            Represents King/Nine offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK8s">
            <summary>
            Represents King/Eight suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK8o">
            <summary>
            Represents King/Eight offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK7s">
            <summary>
            Represents King/Seven suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK7o">
            <summary>
            Represents King/Seven offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK6s">
            <summary>
            Represents King/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK6o">
            <summary>
            Represents King/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK5s">
            <summary>
            Represents King/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK5o">
            <summary>
            Represents King/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK4s">
            <summary>
            Represents King/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK4o">
            <summary>
            Represents King/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK3s">
            <summary>
            Represents King/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK3o">
            <summary>
            Represents King/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK2s">
            <summary>
            Represents King/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketK2o">
            <summary>
            Represents King/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQJs">
            <summary>
            Represents Queen/Jack suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQJo">
            <summary>
            Represents Queen/Jack offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQTs">
            <summary>
            Represents Queen/Ten suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQTo">
            <summary>
            Represents Queen/Ten offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ9s">
            <summary>
            Represents Queen/Nine suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ9o">
            <summary>
            Represents Queen/Nine offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ8s">
            <summary>
            Represents Queen/Eight suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ8o">
            <summary>
            Represents Queen/Eight offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ7s">
            <summary>
            Represents Queen/Seven suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ7o">
            <summary>
            Represents Queen/Seven offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ6s">
            <summary>
            Represents Queen/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ6o">
            <summary>
            Represents Queen/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ5s">
            <summary>
            Represents Queen/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ5o">
            <summary>
            Represents Queen/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ4s">
            <summary>
            Represents Queen/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ4o">
            <summary>
            Represents Queen/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ3s">
            <summary>
            Represents Queen/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ3o">
            <summary>
            Represents Queen/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ2s">
            <summary>
            Represents Queen/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketQ2o">
            <summary>
            Represents Queen/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJTs">
            <summary>
            Represents Jack/Ten suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJTo">
            <summary>
            Represents Jack/Ten offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ9s">
            <summary>
            Represents Jack/Nine suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ9o">
            <summary>
            Represents Jack/Nine offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ8s">
            <summary>
            Represents Jack/Eight suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ8o">
            <summary>
            Represents Jack/Eight offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ7s">
            <summary>
            Represents Jack/Seven suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ7o">
            <summary>
            Represents Jack/Seven offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ6s">
            <summary>
            Represents Jack/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ6o">
            <summary>
            Represents Jack/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ5s">
            <summary>
            Represents Jack/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ5o">
            <summary>
            Represents Jack/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ4s">
            <summary>
            Represents Jack/Four suited.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ4o">
            <summary>
            Represents Jack/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ3s">
            <summary>
            Represents Jack/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ3o">
            <summary>
            Represents Jack/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ2s">
            <summary>
            Represents Jack/Two suited.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketJ2o">
            <summary>
            Represents Jack/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT9s">
            <summary>
            Represents Ten/Nine suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT9o">
            <summary>
            Represents Ten/Nine offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT8s">
            <summary>
            Represents Ten/Eigth suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT8o">
            <summary>
            Represents Ten/Eight offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT7s">
            <summary>
            Represents Ten/Seven suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT7o">
            <summary>
            Represents Ten/Seven offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT6s">
            <summary>
            Represents Ten/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT6o">
            <summary>
            Represents Ten/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT5s">
            <summary>
            Represents Ten/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT5o">
            <summary>
            Represents Ten/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT4s">
            <summary>
            Represents Ten/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT4o">
            <summary>
            Represents Ten/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT3s">
            <summary>
            Represents Ten/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT3o">
            <summary>
            Represents Ten/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT2s">
            <summary>
            Represents Ten/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.PocketT2o">
            <summary>
            Represents Ten/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket98s">
            <summary>
            Represents Nine/Eight suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket98o">
            <summary>
            Represents Nine/Eight offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket97s">
            <summary>
            Represents Nine/Seven suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket97o">
            <summary>
            Represents Nine/Seven offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket96s">
            <summary>
            Represents Nine/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket96o">
            <summary>
            Represents Nine/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket95s">
            <summary>
            Represents Nine/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket95o">
            <summary>
            Represents Nine/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket94s">
            <summary>
            Represents Nine/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket94o">
            <summary>
            Represents Nine/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket93s">
            <summary>
            Represents Nine/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket93o">
            <summary>
            Represents Nine/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket92s">
            <summary>
            Represents Nine/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket92o">
            <summary>
            Represents Nine/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket87s">
            <summary>
            Represents Eight/Seven Suited.
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket87o">
            <summary>
            Represents Eight/Seven offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket86s">
            <summary>
            Represents Eight/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket86o">
            <summary>
            Represents Eight/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket85s">
            <summary>
            Represents Eight/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket85o">
            <summary>
            Represents Eight/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket84s">
            <summary>
            Represents Eight/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket84o">
            <summary>
            Represents Eight/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket83s">
            <summary>
            Represents Eight/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket83o">
            <summary>
            Represents Eight/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket82s">
            <summary>
            Represents Eight/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket82o">
            <summary>
            Represents Eight/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket76s">
            <summary>
            Represents Seven/Six suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket76o">
            <summary>
            Represents Seven/Six offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket75s">
            <summary>
            Represents Seven/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket75o">
            <summary>
            Represents Seven/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket74s">
            <summary>
            Represents Seven/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket74o">
            <summary>
            Represents Seven/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket73s">
            <summary>
            Represents Seven/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket73o">
            <summary>
            Represents Seven/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket72s">
            <summary>
            Represents Seven/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket72o">
            <summary>
            Represents Seven/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket65s">
            <summary>
            Represents Six/Five suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket65o">
            <summary>
            Represents Six/Five offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket64s">
            <summary>
            Represents Six/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket64o">
            <summary>
            Represents Six/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket63s">
            <summary>
            Represents Six/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket63o">
            <summary>
            Represents Six/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket62s">
            <summary>
            Represents Six/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket62o">
            <summary>
            Represents Six/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket54s">
            <summary>
            Represents Five/Four suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket54o">
            <summary>
            Represents Five/Four offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket53s">
            <summary>
            Represents Five/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket53o">
            <summary>
            Represents Five/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket52s">
            <summary>
            Represents Five/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket52o">
            <summary>
            Represents Five/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket43s">
            <summary>
            Represent Four/Three suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket43o">
            <summary>
            Represents Four/Three offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket42s">
            <summary>
            Represents Four/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket42o">
            <summary>
            Represents Four/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket32s">
            <summary>
            Represents Three/Two suited
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.PocketHand169Enum.Pocket32o">
            <summary>
            Represents Three/Two offsuit
            </summary>
        </member>
        <member name="F:HoldemHand.Hand.pocketdict">
            <exclude/>
        </member>
        <member name="M:HoldemHand.Hand.PocketHand169Type(System.UInt64)">
            <summary>
            Given a pocket pair mask, the PocketHand169Enum cooresponding to this mask
            will be returned. 
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.Hands(System.Int32)">
             <summary>
             Enables a foreach command to enumerate all possible ncard hands.
             </summary>
             <param name="numberOfCards">the number of cards in the mask (must be between 1 and 7)</param>
             <returns></returns>
             <example>
             <code>
             // This method iterates through all possible 5 card hands and returns a count.
             public static long CountFiveCardHands()
             {
                 long count = 0;
             
                 // Iterate through all possible 5 card hands
                 foreach (ulong mask in Hands(5))
                 {
                     count++;
                 }
            
                 // Validate results.
                 System.Diagnostics.Debug.Assert(count == 2598960);
                 return count;
             }
             </code>
             </example>
        </member>
        <member name="M:HoldemHand.Hand.Hands(System.UInt64,System.UInt64,System.Int32)">
            <summary>
            Enables a foreach command to enumerate all possible ncard hands.
            </summary>
            <param name="shared">A bitfield containing the cards that must be in the enumerated hands</param>
            <param name="dead">A bitfield containing the cards that must not be in the enumerated hands</param>
            <param name="numberOfCards">the number of cards in the mask (must be between 1 and 7)</param>
            <returns></returns>
            <example>
            <code>
            // Counts all remaining hands in a 7 card holdem mask.
            static long CountHands(string partialHand)
            {
                long count = 0;
            
                // Parse mask and create a mask
                ulong partialHandmask = Hand.ParseHand(partialHand);
            
                // iterate through all 7 card hands that share the cards in our partial mask.
               foreach (ulong handmask in Hand.Hands(partialHandmask, 0UL, 7))
               {
                   count++;
               }
            
               return count;
             }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.Hand.Cards(System.UInt64)">
            <summary>
            This method allows a foreach statement to iterate through each
            card in a card mask.
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.QueryPerformanceCounter(System.Int64@)">
            <summary>
            C# Interop call to Win32 QueryPerformanceCount. This function should be removed
            if you need an interop free class definition.
            </summary>
            <param name="lpPerformanceCount">returns performance counter</param>
            <returns>True if successful, false otherwise</returns>
        </member>
        <member name="M:HoldemHand.Hand.QueryPerformanceFrequency(System.Int64@)">
            <summary>
            C# Interop call to Win32 QueryPerformanceFrequency. This function should be removed
            if you need an interop free class definition.
            </summary>
            <param name="lpFrequency">returns performance frequence</param>
            <returns>True if successful, false otherwise</returns>
        </member>
        <member name="F:HoldemHand.Hand.QueryFrequency">
            <exclude/>
        </member>
        <member name="P:HoldemHand.Hand.CurrentTime">
            <summary>
            Returns a current time indicator that is useful for doing time delta measurements.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.Hand.srand">
            <summary>
            
            </summary>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.UInt64[],System.UInt64,System.Int32)">
            <summary>
            This method randomly picks from a list of possible masks.
            </summary>
            <param name="list">The list of masks to pick from.</param>
            <param name="dead">A mask containing cards that must not be chosen</param>
            <param name="ncards">The number of cards to return</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.Random,System.UInt64[],System.UInt64,System.Int32)">
            <summary>
            This method randomly picks from a list of possible masks. 
            </summary>
            <param name="rand">Random number generator.</param>
            <param name="list">The list of masks to pick from.</param>
            <param name="dead">A mask containing cards that must not be chosen</param>
            <param name="ncards">The number of cards to return</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.Random,System.String,System.UInt64,System.Int32)">
            <summary>
            This method will randomly chose a pocket mask from the query string that doesn't contain any of the specified dead cards.
            That pocket mask will be used as a set of shared cards that must be used in the final generated mask. The mask will contain
            the number of cards specified in the ncards argument.
            </summary>
            <param name="rand">Random number generator.</param>
            <param name="query">A pocket mask query string</param>
            <param name="dead">A set of cards that may not be used in the generated mask as a mask mask</param>
            <param name="ncards">The number of cards that must be in the final mask.</param>
            <returns>A randomly chosen mask mask that meets the input criterion</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.UInt64,System.UInt64,System.Int32)">
            <summary>
            Returns a rand mask with the specified number of cards and constrained
            to not contain any of the passed dead cards. This method is not thread safe!
            </summary>
            <param name="shared"></param>
            <param name="dead">Mask for the cards that must not be returned.</param>
            <param name="ncards">The number of cards to return in this mask.</param>
            <returns>A randomly chosen mask containing the number of cards requested.</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.Random,System.UInt64,System.UInt64,System.Int32)">
            <summary>
            Returns a rand mask with the specified number of cards and constrained
            to not contain any of the passed dead cards.
            </summary>
            <param name="rand">Random number generator</param>
            <param name="shared"></param>
            <param name="dead">Mask for the cards that must not be returned.</param>
            <param name="ncards">The number of cards to return in this mask.</param>
            <returns>A randomly chosen mask containing the number of cards requested.</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.Random,System.UInt64,System.Int32)">
            <summary>
            Returns a randomly generated mask that doesn't include any of the cards in the
            dead card mask. The mask will return the number of card in the ncards argument.
            </summary>
            <param name="rand">Random number generator.</param>
            <param name="dead">The mask of cards that may not be used in the generated mask</param>
            <param name="ncards">The number of cards to return in the generated mask</param>
            <returns>The generated mask as a mask mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.UInt64,System.Int32)">
            <summary>
            
            </summary>
            <param name="dead"></param>
            <param name="ncards"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHand(System.Random,System.Int32)">
            <summary>
            This method will return a random mask with the number of cards specified.
            </summary>
            <param name="rand">Random number generator.</param>
            <param name="ncards">The number of cards to return</param>
            <returns>A randomly chosen mask returned as a mask mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHands(System.UInt64,System.UInt64,System.Int32,System.Int32)">
            <summary>
            This function iterates through random hands returning the number of random hands specified
            in trials. Please note that a mask can be repeated.
            </summary>
            <param name="shared">Cards that must be in the mask.</param>
            <param name="dead">Cards that must not be in the mask.</param>
            <param name="ncards">The total number of cards in the mask.</param>
            <param name="trials">The total number of random hands to return.</param>
            <returns>Returns a random mask mask meeting the input specifications.</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHands(System.Int32,System.Int32)">
            <summary>
            Iterates through random hands with ncards number of cards. This iterator
            will return the number of masks specifed in trials. Masks can be repeated.
            </summary>
            <param name="ncards">Number of cards required to be in the mask.</param>
            <param name="trials">Number of total mask to return.</param>
            <returns>A random mask as a mask mask.</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHands(System.String,System.UInt64,System.Int32,System.Double)">
            <summary>
            Interate through the hands defined in the pocket mask definition.
            </summary>
            <param name="query">Pocket card string</param>
            <param name="dead">Cards not allowed.</param>
            <param name="ncards">The number of cards the returned mask</param>
            <param name="duration">The time allowed for iterating</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHands(System.UInt64[],System.UInt64,System.Int32,System.Double)">
            <summary>
            Returns random hands out of the list of mask provided.
            </summary>
            <param name="list">List of possible hands</param>
            <param name="dead">Cards not allowed</param>
            <param name="ncards">Total number of cards in returned mask</param>
            <param name="duration">The time allowed for iterating</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHands(System.UInt64,System.UInt64,System.Int32,System.Double)">
            <summary>
            Iterates through random hands that meets the specified requirements until the specified
            time duration has elapse. 
            
            Please note that this iterator requires interop. If you need
            and interop free mask evaluator you should remove this function along with the other interop
            functions in this file.
            </summary>
            <param name="shared">These cards must be included in the returned mask</param>
            <param name="dead">These cards must not be included in the returned mask</param>
            <param name="ncards">The number of cards in the returned random mask.</param>
            <param name="duration">The amount of time to allow the generation of hands to occur. When elapsed, the iterator will terminate.</param>
            <returns>A mask mask</returns>
        </member>
        <member name="M:HoldemHand.Hand.RandomHands(System.Int32,System.Double)">
            <summary>
            Iterates through random hands that meets the specified requirements until the specified
            time duration has elapse. 
            
            Please note that this iterator requires interop. If you need
            and interop free mask evaluator you should remove this function along with the other interop
            functions in this file.
            </summary>
            <param name="ncards">The number of cards in the returned mask.</param>
            <param name="duration">The amount of time to allow the generation of hands to occur. When elapsed, the iterator will terminate.</param>
            <returns>A mask mask.</returns>
        </member>
        <member name="T:HoldemHand.PocketHands">
            <summary>
            Represents a set of pocket hands and operations that
            can be applied to them.
            </summary>
            <summary>
            Represents a set of pocket hands and operations that
            can be applied to them.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.list">
            <summary>
            Contains a list of the masks contains in this hole card collection.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._PocketGroupings">
            <summary>
            Sklansky groupings 
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._connectedTable">
            <summary>
            The card masked of pocket card sets that are connected such as 23o
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._suitedTable">
            <summary>
            The list of all pocket hands that are suited.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._pairTable">
            <summary>
            A list of all pocket cards combinations that represent pairs
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._gap1Table">
            <summary>
            A list of all pocket card combintations such as 42o that have a gap of 1 cards.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._gap2Table">
            <summary>
            A list of all pocket card combintations such as 52o that have a gap of 2 cards.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._gap3Table">
            <summary>
            A list of all pocket card combintations such as 62o that have a gap of 3 cards.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._PocketTableMasks">
            <summary>
            The 1326 pocket card combinations.
            </summary>
        </member>
        <member name="T:HoldemHand.PocketHands.GroupTypeEnum">
            <summary>
            Pocket Card Groupings (Group1 is best, None is worst). 
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group1">
            <summary>
            Strongest
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group2">
            <summary>
            Very Strong
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group3">
            <summary>
            
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group4">
            <summary>
            
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group5">
            <summary>
            
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group6">
            <summary>
            
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group7">
            <summary>
            
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.Group8">
            <summary>
            
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.GroupTypeEnum.None">
            <summary>
            Not in the group
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.groupTypeDict">
            <exclude/>
        </member>
        <member name="M:HoldemHand.PocketHands.GroupType(System.UInt64)">
            <summary>
            Returns pocket grouping info for a given pocket cards. This is similar to but 
            different from Sklansky groupings. It may be used just like Sklansky groupings
            and for most tables the this grouping and Sklansky groupings are identical.
            </summary>
            <param name="mask">pocket mask to group</param>
            <returns>An enum value representing the pocket grouping rank.</returns>
        </member>
        <member name="F:HoldemHand.PocketHands._PocketCards169Gap">
            <summary>
            This table contains the gap count for each of the 169 mask types. The index cooresponds PocketHand169Enum.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._PocketCards169Connected">
            <summary>
            This table is true for entries in the PocketCards169 table that are connected.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._PocketCards169Suited">
            <summary>
            This table contains the suited boolean value for each of the 169 mask types. The index cooresponds PocketHand169Enum.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._Pocket169Combinations">
            <summary>
            The 1326 possible pocket cards ordered by the 169 unique holdem combinations. The
            index is equivalent to the number value of Hand.PocketHand169Enum.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.PocketTableMasks">
            <summary>
            The 1326 pocket card combinations.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.PocketCards169Strings">
            <summary>
            A string table cooresponding to the PocketHand169Enum enumeration. 
            The index of each string should correspond to the integer value
            associated with enumerator entry.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands.pocket169StringToEnum">
            <exclude/>
        </member>
        <member name="M:HoldemHand.PocketHands.PocketCard169StringToEnum(System.String)">
            <summary>
            Takes as Pocket Card 169 string definition and returns the cooresponding PocketHand169Enum enum
            value.
            </summary>
            <param name="s">String representing the pocket card 169 type</param>
            <returns>The equivalent enum value in PocketHand169Enum</returns>
        </member>
        <member name="F:HoldemHand.PocketHands._Pocket169ProbTable">
            <summary>
            Probablity of beating one other random player with
            This pocket card combination.
            </summary>
        </member>
        <member name="M:HoldemHand.PocketHands.WinOdds(System.UInt64)">
            <summary>
            Returns the probablity of the specified two card pocket mask winning against
            a random opponent. This is just a table lookup so the results are fairly quick.
            </summary>
            <param name="mask">2 card pocket mask</param>
        </member>
        <member name="M:HoldemHand.PocketHands.PocketHand169TypeCount(System.UInt64)">
            <summary>
            Returns the number of elements of the pocket type corresponding
            to this mask.
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.IsConnected(System.UInt64)">
            <summary>
            Returns true if the 2 card pocket mask passed is connected. This function is a lookup so
            it is reasonably fast.
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.IsSuited(System.UInt64)">
            <summary>
            Returns true if the two card pocket mask passed is suited. This method is a lookup so it is 
            quite fast.
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.GapCount(System.UInt64)">
            <summary>
            This method returns the gap count which is the distance between two pocket cards.
            For example, As 2h has a gap of 0 while As 3h has a gap of 1. The values returned are
            0, 1, 2, 3 or -1.
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._card169ToTypeTable">
            <exclude/>
        </member>
        <member name="M:HoldemHand.PocketHands.Pocket169(System.String)">
            <summary>
            Given a string, the corresponding PocketHand169Enum is returned.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._card169fixtable">
            <exclude/>
        </member>
        <member name="M:HoldemHand.PocketHands.FindFixCard169(System.String)">
            <summary>
            I goofed up the text description of the 169 card hands. I originally
            used my own syntax rather than the one Sklansky uses in his book. I released
            after working through is books, that I should have used his syntax (even
            though I think it's a bit confusing). This functions converts the Sklansky 
            syntax to mine. 
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.FixCard169(System.String)">
            <summary>
            See FindFixCard169() description.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.BuildFix169Table">
            <summary>
            See FindFixCard169 description
            </summary>
        </member>
        <member name="M:HoldemHand.PocketHands.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:HoldemHand.PocketHands.#ctor(HoldemHand.PocketHands)">
            <summary>
            Constructor
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:HoldemHand.PocketHands.#ctor(System.UInt64[])">
            <summary>
            Constructor
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:HoldemHand.PocketHands.#ctor(System.UInt64)">
            <summary>
            Constructor
            </summary>
            <param name="mask"></param>
        </member>
        <member name="M:HoldemHand.PocketHands.#ctor(System.Collections.Generic.List{System.UInt64})">
            <summary>
            Constructor
            </summary>
            <param name="arg"></param>
        </member>
        <member name="F:HoldemHand.PocketHands._allhands">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.AllHands">
            <summary>
            Creates and instance of PocketHands with all 1326 possible pocket cards.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._connected">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Connected">
            <summary>
            Creates an instance of PocketHands which are connected.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._suited">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Suited">
            <summary>
            Creates an instance of PocketHands which contain all of the possible suited hands.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._offsuit">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Offsuit">
            <summary>
            Creates an instance of PocketHands which contain all of the possible offsuit hands.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._pair">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Pair">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket pairs.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._gap1">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Gap1">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands with gap of one.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._gap2">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Gap2">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands with gap of two.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._gap3">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Gap3">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands with gap of three.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._gap">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Gap">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands with gap a gap of one, two or three.
            </summary>
            <returns></returns>
        </member>
        <member name="F:HoldemHand.PocketHands._group1">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group1">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group1.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._group2">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group2">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group2.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._group3">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group3">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group3.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._group4">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group4">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group4.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._group5">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group5">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group5.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._group6">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group6">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group6.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._group7">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group7">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group7.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._group8">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.Group8">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are in Skalansky group8.
            </summary>
        </member>
        <member name="F:HoldemHand.PocketHands._groupnone">
            <exclude/>
        </member>
        <member name="P:HoldemHand.PocketHands.GroupNone">
            <summary>
            Creates an instance of PocketHands that contains all possible pocket hands that are not in any of the Skalansky groups.
            </summary>
        </member>
        <member name="M:HoldemHand.PocketHands.PocketCards(System.String)">
            <summary>
            Creates an instance of PocketHands that contains the specified pocket cards.
            Valid strings are "As Kd" for Ace Spaces and a King of Diamonds and so on.
            </summary>
            <param name="pocket"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.PocketCards169(System.String)">
            <summary>
            Creates an instance of PocketHands that contains all of the hands specified by the Card 169 string. 
            Valid strings are AKs (Ace/King suited), AA (A pair of aces) and so on.
            </summary>
            <param name="pocket"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Condense169(HoldemHand.PocketHands)">
            <summary>
            This methods reduces the hands passed in hands to a set of that represents one of each of the
            169 mask types (if such a mask exists).
            </summary>
            <param name="hands"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.RemoveDead(System.UInt64,HoldemHand.PocketHands)">
            <summary>
            The method removes all of the cards specified in the bit mask from the PocketHands passed in hands.
            </summary>
            <param name="dead"></param>
            <param name="hands"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Card169Max(System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Card169Min(System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.PocketCards169Wild(System.String)">
            <summary>
            Creates an instance of PocketHands given a 169 wild card string. For example
            AX would be and Ace and a rag. K?s would be a King and any other card suited.
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.PocketCards169Range(System.String,System.String)">
            <summary>
            Allows a range of 169 cards definitions for example Pocketcard169Range("AA", "22") would create
            a representation of all of the possible pairs. This method assumes that the 169 card definitions have
            an order. This order is AA-22, AKs, AKo, AQs, AQo and so on.
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.PocketCard169Range(HoldemHand.Hand.PocketHand169Enum,HoldemHand.Hand.PocketHand169Enum)">
            <summary>
            Allows a range of 169 cards definitions for example Pocketcard169Range(Hand.PocketHand169Enum.PocketAA, Hand.PocketHand169Enum.Pocket22) would create
            a representation of all of the possible pairs. This method assumes that the 169 card definitions have
            an order. This order is AA-22, AKs, AKo, AQs, AQo and so on.
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Group(HoldemHand.PocketHands.GroupTypeEnum)">
            <summary>
            Given a PocketGroupingRank (Sklansky group value) all of the pockethands that are in the
            specified group are returned.
            </summary>
            <param name="rank"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.GroupRange(HoldemHand.PocketHands.GroupTypeEnum,HoldemHand.PocketHands.GroupTypeEnum)">
            <summary>
            Given a PocketGroupRank range, all of the pockethands that are between (and including) the specfied groups
            are returned.
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_BitwiseOr(HoldemHand.PocketHands,HoldemHand.PocketHands)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_BitwiseOr(HoldemHand.PocketHands,System.UInt64[])">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_BitwiseOr(System.UInt64[],HoldemHand.PocketHands)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_BitwiseOr(HoldemHand.PocketHands,System.UInt64)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Addition(HoldemHand.PocketHands,HoldemHand.PocketHands)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Addition(HoldemHand.PocketHands,System.UInt64)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Addition(System.UInt64,HoldemHand.PocketHands)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Addition(HoldemHand.PocketHands,System.UInt64[])">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Addition(System.UInt64[],HoldemHand.PocketHands)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Addition(HoldemHand.PocketHands,System.Collections.Generic.List{System.UInt64})">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Addition(System.Collections.Generic.List{System.UInt64},HoldemHand.PocketHands)">
            <summary>
            This is a union operator. It combines all elements of the two collections into
            one combined collection.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_BitwiseAnd(HoldemHand.PocketHands,HoldemHand.PocketHands)">
            <summary>
            This is a intersection operator. It produces a collection of the elements that are in
            both of the specified arguments.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_BitwiseAnd(HoldemHand.PocketHands,System.UInt64[])">
            <summary>
            This is a intersection operator. It produces a collection of the elements that are in
            both of the specified arguments.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_BitwiseAnd(System.UInt64[],HoldemHand.PocketHands)">
            <summary>
            This is a intersection operator. It produces a collection of the elements that are in
            both of the specified arguments.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Subtraction(HoldemHand.PocketHands,System.UInt64)">
            <summary>
            This operator returns a collection with all of the cards defined in the dead card mask set removed from the PocketHands collection.
            This can be used to remove dead cards from any PocketHands collection.
            </summary>
            <param name="arg"></param>
            <param name="dead"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Subtraction(HoldemHand.PocketHands,System.Collections.Generic.List{System.UInt64})">
            <summary>
            This operator returns a collection with all of the pocket hands defined in arg2 set removed from the PocketHands collection defined in arg1.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Subtraction(System.Collections.Generic.List{System.UInt64},HoldemHand.PocketHands)">
            <summary>
            This operator returns a collection with all of the pocket hands defined in arg2 set removed from the collection defined in arg1.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Subtraction(HoldemHand.PocketHands,HoldemHand.PocketHands)">
            <summary>
            This operator returns a collection with all of the pocket hands defined in arg2 set removed from the PocketHands collection defined in arg1.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Subtraction(HoldemHand.PocketHands,System.UInt64[])">
            <summary>
            This operator returns a collection with all of the pocket hands defined in arg2 set removed from the collection defined in arg1.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Subtraction(System.UInt64[],HoldemHand.PocketHands)">
            <summary>
            This operator returns a collection with all of the pocket hands defined in arg2 set removed from the collection defined in arg1.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_LogicalNot(HoldemHand.PocketHands)">
            <summary>
            This operation returns all the possible pocket hands that aren't in arg.
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Equality(HoldemHand.PocketHands,HoldemHand.PocketHands)">
            <summary>
            Compares arg1 to arg2 for equality. Order doesn't matter, but both collections must
            contain the same elements.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Inequality(HoldemHand.PocketHands,HoldemHand.PocketHands)">
            <summary>
            This operator compares two PocketHands collections for inequality.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Equality(System.UInt64[],HoldemHand.PocketHands)">
            <summary>
            This oprator compares two collections of pocket hands for equality. 
            Note: order doesn't matter.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Inequality(System.UInt64[],HoldemHand.PocketHands)">
            <summary>
            This operator compares two pocket mask collections for inequality.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Equality(System.Collections.Generic.List{System.UInt64},HoldemHand.PocketHands)">
            <summary>
            This oprator compares two collections of pocket hands for equality. 
            Note: order doesn't matter.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Inequality(System.Collections.Generic.List{System.UInt64},HoldemHand.PocketHands)">
            <summary>
            This operator compares two pocket mask collections for inequality.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Equality(HoldemHand.PocketHands,System.UInt64[])">
            <summary>
            This oprator compares two collections of pocket hands for equality. 
            Note: order doesn't matter.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Inequality(HoldemHand.PocketHands,System.UInt64[])">
            <summary>
            This operator compares two pocket mask collections for inequality.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Equality(HoldemHand.PocketHands,System.Collections.Generic.List{System.UInt64})">
            <summary>
            This oprator compares two collections of pocket hands for equality. 
            Note: order doesn't matter.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Inequality(HoldemHand.PocketHands,System.Collections.Generic.List{System.UInt64})">
            <summary>
            This operator compares two pocket mask collections for inequality.
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_LessThan(HoldemHand.PocketHands,System.Double)">
            <summary>
            Compares each element of the PocketHands argument to see if
            it's win percentage is less than arg2.
            </summary>
            <param name="arg1">PocketHands collection to compare</param>
            <param name="arg2">Win Value</param>
            <returns>A PocketHands collection where each item has win odds less than arg2</returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_LessThanOrEqual(HoldemHand.PocketHands,System.Double)">
            <summary>
            Compares each element of the PocketHands argument to see if
            it's win percentage is less than or equal to arg2.
            </summary>
            <param name="arg1">PocketHands collection to compare</param>
            <param name="arg2">Win Value</param>
            <returns>A PocketHands collection where each item has win odds less than or equal to arg2</returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_GreaterThan(HoldemHand.PocketHands,System.Double)">
            <summary>
            Compares each element of the PocketHands argument to see if
            it's win percentage is greater than arg2.
            </summary>
            <param name="arg1">PocketHands collection to compare</param>
            <param name="arg2">Win Value</param>
            <returns>A PocketHands collection where each item has win odds greater than arg2</returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_GreaterThanOrEqual(HoldemHand.PocketHands,System.Double)">
            <summary>
            Compares each element of the PocketHands argument to see if
            it's win percentage is greater than or equal to arg2.
            </summary>
            <param name="arg1">PocketHands collection to compare</param>
            <param name="arg2">Win Value</param>
            <returns>A PocketHands collection where each item has win odds greater than or equal arg2</returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_LessThanOrEqual(HoldemHand.PocketHands,HoldemHand.Hand.PocketHand169Enum)">
            <summary>
            This operator returns all PocketHands that are in arg and are less than or equal to the
            169 mask type specified in the argument type.
            </summary>
            <param name="arg"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_LessThan(HoldemHand.PocketHands,HoldemHand.Hand.PocketHand169Enum)">
            <summary>
            This operator returns all PocketHands that are in arg and are less than to the
            169 mask type specified in the argument type.
            </summary>
            <param name="arg1"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_GreaterThan(HoldemHand.PocketHands,HoldemHand.Hand.PocketHand169Enum)">
            <summary>
            This operator returns all PocketHands that are in arg and are greater than to the
            169 mask type specified in the argument type.
            </summary>
            <param name="arg"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_GreaterThanOrEqual(HoldemHand.PocketHands,HoldemHand.Hand.PocketHand169Enum)">
            <summary>
            This operator returns all PocketHands that are in arg and are greater than or equal to the
            169 mask type specified in the argument type.
            </summary>
            <param name="arg"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_LessThan(HoldemHand.PocketHands,HoldemHand.PocketHands.GroupTypeEnum)">
            <summary>
            This operator returns all PocketHands that are in arg and are less than the
            sklansky group type specified in the argument type.
            </summary>
            <param name="arg"></param>
            <param name="rank"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_LessThanOrEqual(HoldemHand.PocketHands,HoldemHand.PocketHands.GroupTypeEnum)">
            <summary>
            This operator returns all PocketHands that are in arg and are less than or equal to the
            sklansky group type specified in the argument type.
            </summary>
            <param name="arg"></param>
            <param name="rank"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_GreaterThan(HoldemHand.PocketHands,HoldemHand.PocketHands.GroupTypeEnum)">
            <summary>
            This operator returns all PocketHands that are in arg and are greter than the
            sklansky group type specified in the argument type.
            </summary>
            <param name="arg"></param>
            <param name="rank"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_GreaterThanOrEqual(HoldemHand.PocketHands,HoldemHand.PocketHands.GroupTypeEnum)">
            <summary>
            This operator returns all PocketHands that are in arg and are greater than or equal to the
            sklansky group type specified in the argument type.
            </summary>
            <param name="arg"></param>
            <param name="rank"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.LT(HoldemHand.PocketHands,System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.LE(HoldemHand.PocketHands,System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.GT(HoldemHand.PocketHands,System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.GE(HoldemHand.PocketHands,System.String)">
            <summary>
            
            </summary>
            <param name="arg"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Hands169(System.UInt64,System.UInt64)">
            <summary>
            This method allows only one of each representative type of pocket mask to
            be iterated through. It might be preferred of over Hand.Hands() if you wish
            to reduce the number of pocket hands considered, but still cover all of the types of 
            pocket hands.
            </summary>
            <code>
            using System;
            using System.Collections.Generic;
            using HoldemHand;
            
            namespace ConsoleApplication1
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        int count = 0;
                        foreach (ulong mask in PocketHands.Hands169())
                        {
                            count++;
                        }
                        // Prints out 169
                        Console.WriteLine("count {0}", count);
                    }
                }
            }
            </code>
            <param name="shared">The cards must be in the pocket mask</param>
            <param name="dead">These cards must not be in the pocket mask</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Hands169(System.UInt64)">
            <summary>
            This method allows only one of each representative type of pocket mask to
            be iterated through. It might be preferred of over Hand.Hands() if you wish
            to reduce the number of pocket hands considered, but still cover all of the types of 
            pocket hands.
            </summary>
            <code>
            using System;
            using System.Collections.Generic;
            using HoldemHand;
            
            namespace ConsoleApplication1
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        int count = 0;
                        foreach (ulong mask in PocketHands.Hands169())
                        {
                            count++;
                        }
                        // Prints out 169
                        Console.WriteLine("count {0}", count);
                    }
                }
            }
            </code>
            <param name="dead">These cards must not be in the pocket mask</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Hands169">
            <summary>
            This method allows only one of each representative type of pocket mask to
            be iterated through. It might be preferred of over Hand.Hands() if you wish
            to reduce the number of pocket hands considered, but still cover all of the types of 
            pocket hands.
            </summary>
            <code>
            using System;
            using System.Collections.Generic;
            using HoldemHand;
            
            namespace ConsoleApplication1
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        int count = 0;
                        foreach (ulong mask in PocketHands.Hands169())
                        {
                            count++;
                        }
                        // Prints out 169
                        Console.WriteLine("count {0}", count);
                    }
                }
            }
            </code>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Hands(System.UInt64[],System.UInt64,System.Int32)">
            <summary>
            This method iterates through the all of the hands with the specified number of
            cards that contain one of the sets of cards in the list array. 
            </summary>
            <param name="list">The list of cards sets (probably pocket hands) that one of which must be in the returned mask</param>
            <param name="dead">A mask of the cards that must not be in the returned mask</param>
            <param name="numberOfCards">The number of cards in the returned mask</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Hands(System.String,System.UInt64,System.Int32)">
            <summary>
            Iterates through all of the hands that contain a pocket mask from the set
            pocket hands defined in the query string.
            </summary>
            <param name="query">A pocket mask query string</param>
            <param name="dead">A mask of cards that must no be included in the returned mask</param>
            <param name="numberOfCards">The number of cards in the returned mask</param>
            <returns>Hand mask</returns>
            <example>
            <code>
            using System;
            using HoldemHand;
            
            namespace ConsoleApplication1
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        long count = 0;
                        foreach (ulong mask in PocketHands.Hands("AKs", 0UL, 7))
                        {
                            count++;
                        }
                        Console.WriteLine("count: {0}", count);
                     }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:HoldemHand.PocketHands.GetEnumerator">
            <summary>
            This method makes it possible to use the foreach statement
            on this class. This method has a typed return value so that 
            box/unbox is not needed while iterating.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            This method makes it possible to use the foreach statement
            on this class.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.ToArray">
            <summary>
            Converts a PocketHands collection into a ulong[].
            </summary>
            <returns></returns>
        </member>
        <member name="P:HoldemHand.PocketHands.Count">
            <summary>
            Returns the number of ulong values in the pocket mask collection.
            </summary>
        </member>
        <member name="P:HoldemHand.PocketHands.Item(System.Int32)">
            <summary>
            Returns the value associated with a specific index of the collection.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Contains(System.UInt64)">
            <summary>
            Returns true if the collection already contains the specified mask.
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.GetHashCode">
            <summary>
            Calculate a hash code for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Equals(System.Object)">
            <summary>
            Checks this pocket mask collection with another for equality.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.op_Implicit(HoldemHand.PocketHands)~System.UInt64[]">
            <summary>
            Implicit cast
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Query(System.String,System.UInt64)">
            <summary>
            This function allows a text description (or query) of set 
            of pocket hands to be specified such that all of the hands that match
            this query (minus the hands containing any of the cards in the 
            dead mask) will be returned.
            </summary>
            <param name="dead">card mask for dead cards</param>
            <param name="s">string defining PocketHands query</param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.ValidateQuery(System.String,System.UInt64)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="dead"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.ValidateQuery(System.String)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:HoldemHand.PocketHands.Query(System.String)">
            <summary>
            This function allows a text description (or query) of set 
            of pocket hands to be specified such that all of the hands that match
            this query will be returned.
            </summary>
            <param name="s">Query String</param>
            <returns></returns>
        </member>
        <member name="T:Card">
            <exclude/>
        </member>
        <member name="P:Card.yynum">
            <exclude/>
        </member>
        <member name="M:Card.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Card_1">
            <exclude/>
        </member>
        <member name="M:Card_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Card169">
            <exclude/>
        </member>
        <member name="P:Card169.yynum">
            <exclude/>
        </member>
        <member name="M:Card169.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Card169_1">
            <exclude/>
        </member>
        <member name="M:Card169_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Card169Wild">
            <exclude/>
        </member>
        <member name="P:Card169Wild.yynum">
            <exclude/>
        </member>
        <member name="M:Card169Wild.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Card169Wild_1">
            <exclude/>
        </member>
        <member name="M:Card169Wild_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Percent">
            <exclude/>
        </member>
        <member name="P:Percent.yynum">
            <exclude/>
        </member>
        <member name="M:Percent.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Percent_1">
            <exclude/>
        </member>
        <member name="M:Percent_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Number">
            <exclude/>
        </member>
        <member name="P:Number.yynum">
            <exclude/>
        </member>
        <member name="M:Number.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Number_1">
            <exclude/>
        </member>
        <member name="M:Number_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Any">
            <exclude/>
        </member>
        <member name="P:Any.yynum">
            <exclude/>
        </member>
        <member name="M:Any.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Any_1">
            <exclude/>
        </member>
        <member name="M:Any_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped">
            <exclude/>
        </member>
        <member name="P:Gapped.yynum">
            <exclude/>
        </member>
        <member name="M:Gapped.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped_1">
            <exclude/>
        </member>
        <member name="M:Gapped_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped1">
            <exclude/>
        </member>
        <member name="P:Gapped1.yynum">
            <exclude/>
        </member>
        <member name="M:Gapped1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped1_1">
            <exclude/>
        </member>
        <member name="M:Gapped1_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped2">
            <exclude/>
        </member>
        <member name="P:Gapped2.yynum">
            <exclude/>
        </member>
        <member name="M:Gapped2.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped2_1">
            <exclude/>
        </member>
        <member name="M:Gapped2_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped3">
            <exclude/>
        </member>
        <member name="P:Gapped3.yynum">
            <exclude/>
        </member>
        <member name="M:Gapped3.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Gapped3_1">
            <exclude/>
        </member>
        <member name="M:Gapped3_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:To">
            <exclude/>
        </member>
        <member name="P:To.yynum">
            <exclude/>
        </member>
        <member name="M:To.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:To_1">
            <exclude/>
        </member>
        <member name="M:To_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:To_2">
            <exclude/>
        </member>
        <member name="M:To_2.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:To_3">
            <exclude/>
        </member>
        <member name="M:To_3.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Pair">
            <exclude/>
        </member>
        <member name="P:Pair.yynum">
            <exclude/>
        </member>
        <member name="M:Pair.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Pair_1">
            <exclude/>
        </member>
        <member name="M:Pair_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Not">
            <exclude/>
        </member>
        <member name="P:Not.yynum">
            <exclude/>
        </member>
        <member name="M:Not.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Not_1">
            <exclude/>
        </member>
        <member name="M:Not_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Not_2">
            <exclude/>
        </member>
        <member name="M:Not_2.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:But">
            <exclude/>
        </member>
        <member name="P:But.yynum">
            <exclude/>
        </member>
        <member name="M:But.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:But_1">
            <exclude/>
        </member>
        <member name="M:But_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Connected">
            <exclude/>
        </member>
        <member name="P:Connected.yynum">
            <exclude/>
        </member>
        <member name="M:Connected.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Connected_1">
            <exclude/>
        </member>
        <member name="M:Connected_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Suited">
            <exclude/>
        </member>
        <member name="P:Suited.yynum">
            <exclude/>
        </member>
        <member name="M:Suited.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Suited_1">
            <exclude/>
        </member>
        <member name="M:Suited_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Offsuit">
            <exclude/>
        </member>
        <member name="P:Offsuit.yynum">
            <exclude/>
        </member>
        <member name="M:Offsuit.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Offsuit_1">
            <exclude/>
        </member>
        <member name="M:Offsuit_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:LE">
            <exclude/>
        </member>
        <member name="P:LE.yynum">
            <exclude/>
        </member>
        <member name="M:LE.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:LE_1">
            <exclude/>
        </member>
        <member name="M:LE_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:LT">
            <exclude/>
        </member>
        <member name="P:LT.yynum">
            <exclude/>
        </member>
        <member name="M:LT.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:LT_1">
            <exclude/>
        </member>
        <member name="M:LT_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:GE">
            <exclude/>
        </member>
        <member name="P:GE.yynum">
            <exclude/>
        </member>
        <member name="M:GE.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:GE_1">
            <exclude/>
        </member>
        <member name="M:GE_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:GT">
            <exclude/>
        </member>
        <member name="P:GT.yynum">
            <exclude/>
        </member>
        <member name="M:GT.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:GT_1">
            <exclude/>
        </member>
        <member name="M:GT_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:OR">
            <exclude/>
        </member>
        <member name="P:OR.yynum">
            <exclude/>
        </member>
        <member name="M:OR.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:OR_1">
            <exclude/>
        </member>
        <member name="M:OR_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:OR_2">
            <exclude/>
        </member>
        <member name="M:OR_2.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:OR_3">
            <exclude/>
        </member>
        <member name="M:OR_3.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:OR_4">
            <exclude/>
        </member>
        <member name="M:OR_4.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:AND">
            <exclude/>
        </member>
        <member name="P:AND.yynum">
            <exclude/>
        </member>
        <member name="M:AND.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:AND_1">
            <exclude/>
        </member>
        <member name="M:AND_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:AND_2">
            <exclude/>
        </member>
        <member name="M:AND_2.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:IN">
            <exclude/>
        </member>
        <member name="P:IN.yynum">
            <exclude/>
        </member>
        <member name="M:IN.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:IN_1">
            <exclude/>
        </member>
        <member name="M:IN_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:AND_3">
            <exclude/>
        </member>
        <member name="M:AND_3.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:LParen">
            <exclude/>
        </member>
        <member name="P:LParen.yynum">
            <exclude/>
        </member>
        <member name="M:LParen.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:LParen_1">
            <exclude/>
        </member>
        <member name="M:LParen_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:RParen">
            <exclude/>
        </member>
        <member name="P:RParen.yynum">
            <exclude/>
        </member>
        <member name="M:RParen.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:RParen_1">
            <exclude/>
        </member>
        <member name="M:RParen_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group8">
            <exclude/>
        </member>
        <member name="P:Group8.yynum">
            <exclude/>
        </member>
        <member name="M:Group8.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group8_1">
            <exclude/>
        </member>
        <member name="M:Group8_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group7">
            <exclude/>
        </member>
        <member name="P:Group7.yynum">
            <exclude/>
        </member>
        <member name="M:Group7.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group7_1">
            <exclude/>
        </member>
        <member name="M:Group7_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group6">
            <exclude/>
        </member>
        <member name="P:Group6.yynum">
            <exclude/>
        </member>
        <member name="M:Group6.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group6_1">
            <exclude/>
        </member>
        <member name="M:Group6_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group5">
            <exclude/>
        </member>
        <member name="P:Group5.yynum">
            <exclude/>
        </member>
        <member name="M:Group5.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group5_1">
            <exclude/>
        </member>
        <member name="M:Group5_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group4">
            <exclude/>
        </member>
        <member name="P:Group4.yynum">
            <exclude/>
        </member>
        <member name="M:Group4.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group4_1">
            <exclude/>
        </member>
        <member name="M:Group4_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group3">
            <exclude/>
        </member>
        <member name="P:Group3.yynum">
            <exclude/>
        </member>
        <member name="M:Group3.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group3_1">
            <exclude/>
        </member>
        <member name="M:Group3_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group2">
            <exclude/>
        </member>
        <member name="P:Group2.yynum">
            <exclude/>
        </member>
        <member name="M:Group2.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group2_1">
            <exclude/>
        </member>
        <member name="M:Group2_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group1">
            <exclude/>
        </member>
        <member name="P:Group1.yynum">
            <exclude/>
        </member>
        <member name="M:Group1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group1_1">
            <exclude/>
        </member>
        <member name="M:Group1_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group9">
            <exclude/>
        </member>
        <member name="P:Group9.yynum">
            <exclude/>
        </member>
        <member name="M:Group9.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group9_1">
            <exclude/>
        </member>
        <member name="M:Group9_1.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Group9_2">
            <exclude/>
        </member>
        <member name="M:Group9_2.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:yyExam">
            <exclude/>
        </member>
        <member name="M:yyExam.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group3_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.LT_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group2_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.OR_4_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group6_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Card169_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped2_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group5_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.GT_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.IN_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group9_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group8_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.LParen_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.To_3_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Not_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Suited_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group2_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.RParen_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.LParen_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.AND_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.LE_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Percent_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group5_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.But_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group4_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.GE_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.AND_2_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.AND_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group8_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped3_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.RParen_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Pair_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Pair_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Number_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Connected_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped1_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Offsuit_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group4_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.But_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Number_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Percent_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped2_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.AND_3_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.OR_2_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Card_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.LE_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.OR_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Any_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.GE_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Connected_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.To_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group7_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Any_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.LT_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.GT_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped3_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.IN_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Card169Wild_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.OR_3_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Not_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Not_2_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Offsuit_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group1_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group3_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group7_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group9_2_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group6_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.OR_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.To_2_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Group9_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Suited_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Gapped_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Card169_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Card169Wild_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.Card_1_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.To_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:yyExam.OldAction(Tools.Lexer,System.String@,System.Int32,System.Boolean@)">
            <exclude/>
        </member>
        <member name="T:Exam">
            <exclude/>
        </member>
        <member name="M:Exam.#ctor">
            <exclude/>
        </member>
        <member name="M:Exam.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="M:Exam.#ctor(Tools.YyLexer)">
            <exclude/>
        </member>
        <member name="T:SpecDoc">
            <exclude/>
        </member>
        <member name="M:SpecDoc.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="P:SpecDoc.yyname">
            <exclude/>
        </member>
        <member name="P:SpecDoc.yynum">
            <exclude/>
        </member>
        <member name="T:SpecDoc_1">
            <exclude/>
        </member>
        <member name="M:SpecDoc_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:SpecDoc_2">
            <exclude/>
        </member>
        <member name="M:SpecDoc_2.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:SpecDoc_2_1">
            <exclude/>
        </member>
        <member name="M:SpecDoc_2_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:SpecDoc_3">
            <exclude/>
        </member>
        <member name="M:SpecDoc_3.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:SpecDoc_4">
            <exclude/>
        </member>
        <member name="M:SpecDoc_4.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:SpecDoc_4_1">
            <exclude/>
        </member>
        <member name="M:SpecDoc_4_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr">
            <exclude/>
        </member>
        <member name="M:Expr.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="P:Expr.yyname">
            <exclude/>
        </member>
        <member name="P:Expr.yynum">
            <exclude/>
        </member>
        <member name="T:Expr_1">
            <exclude/>
        </member>
        <member name="M:Expr_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_2">
            <exclude/>
        </member>
        <member name="M:Expr_2.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_2_1">
            <exclude/>
        </member>
        <member name="M:Expr_2_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_3">
            <exclude/>
        </member>
        <member name="M:Expr_3.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_4">
            <exclude/>
        </member>
        <member name="M:Expr_4.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_4_1">
            <exclude/>
        </member>
        <member name="M:Expr_4_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_5">
            <exclude/>
        </member>
        <member name="M:Expr_5.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_6">
            <exclude/>
        </member>
        <member name="M:Expr_6.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_6_1">
            <exclude/>
        </member>
        <member name="M:Expr_6_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_7">
            <exclude/>
        </member>
        <member name="M:Expr_7.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_8">
            <exclude/>
        </member>
        <member name="M:Expr_8.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_8_1">
            <exclude/>
        </member>
        <member name="M:Expr_8_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_9">
            <exclude/>
        </member>
        <member name="M:Expr_9.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_10">
            <exclude/>
        </member>
        <member name="M:Expr_10.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_10_1">
            <exclude/>
        </member>
        <member name="M:Expr_10_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_11">
            <exclude/>
        </member>
        <member name="M:Expr_11.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_12">
            <exclude/>
        </member>
        <member name="M:Expr_12.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_12_1">
            <exclude/>
        </member>
        <member name="M:Expr_12_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_13">
            <exclude/>
        </member>
        <member name="M:Expr_13.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_14">
            <exclude/>
        </member>
        <member name="M:Expr_14.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_14_1">
            <exclude/>
        </member>
        <member name="M:Expr_14_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_15">
            <exclude/>
        </member>
        <member name="M:Expr_15.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_16">
            <exclude/>
        </member>
        <member name="M:Expr_16.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_16_1">
            <exclude/>
        </member>
        <member name="M:Expr_16_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_17">
            <exclude/>
        </member>
        <member name="M:Expr_17.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_18">
            <exclude/>
        </member>
        <member name="M:Expr_18.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_18_1">
            <exclude/>
        </member>
        <member name="M:Expr_18_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_19">
            <exclude/>
        </member>
        <member name="M:Expr_19.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_20">
            <exclude/>
        </member>
        <member name="M:Expr_20.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_20_1">
            <exclude/>
        </member>
        <member name="M:Expr_20_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_21">
            <exclude/>
        </member>
        <member name="M:Expr_21.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_22">
            <exclude/>
        </member>
        <member name="M:Expr_22.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_22_1">
            <exclude/>
        </member>
        <member name="M:Expr_22_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_23">
            <exclude/>
        </member>
        <member name="M:Expr_23.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_24">
            <exclude/>
        </member>
        <member name="M:Expr_24.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_24_1">
            <exclude/>
        </member>
        <member name="M:Expr_24_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_25">
            <exclude/>
        </member>
        <member name="M:Expr_25.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_26">
            <exclude/>
        </member>
        <member name="M:Expr_26.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_26_1">
            <exclude/>
        </member>
        <member name="M:Expr_26_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_27">
            <exclude/>
        </member>
        <member name="M:Expr_27.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_28">
            <exclude/>
        </member>
        <member name="M:Expr_28.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_28_1">
            <exclude/>
        </member>
        <member name="M:Expr_28_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_29">
            <exclude/>
        </member>
        <member name="M:Expr_29.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_30">
            <exclude/>
        </member>
        <member name="M:Expr_30.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_30_1">
            <exclude/>
        </member>
        <member name="M:Expr_30_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_31">
            <exclude/>
        </member>
        <member name="M:Expr_31.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_32">
            <exclude/>
        </member>
        <member name="M:Expr_32.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_32_1">
            <exclude/>
        </member>
        <member name="M:Expr_32_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_33">
            <exclude/>
        </member>
        <member name="M:Expr_33.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_34">
            <exclude/>
        </member>
        <member name="M:Expr_34.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_34_1">
            <exclude/>
        </member>
        <member name="M:Expr_34_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_35">
            <exclude/>
        </member>
        <member name="M:Expr_35.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_36">
            <exclude/>
        </member>
        <member name="M:Expr_36.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_36_1">
            <exclude/>
        </member>
        <member name="M:Expr_36_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_37">
            <exclude/>
        </member>
        <member name="M:Expr_37.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_38">
            <exclude/>
        </member>
        <member name="M:Expr_38.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_38_1">
            <exclude/>
        </member>
        <member name="M:Expr_38_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_39">
            <exclude/>
        </member>
        <member name="M:Expr_39.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_40">
            <exclude/>
        </member>
        <member name="M:Expr_40.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_40_1">
            <exclude/>
        </member>
        <member name="M:Expr_40_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_41">
            <exclude/>
        </member>
        <member name="M:Expr_41.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_42">
            <exclude/>
        </member>
        <member name="M:Expr_42.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_42_1">
            <exclude/>
        </member>
        <member name="M:Expr_42_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_43">
            <exclude/>
        </member>
        <member name="M:Expr_43.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_44">
            <exclude/>
        </member>
        <member name="M:Expr_44.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_44_1">
            <exclude/>
        </member>
        <member name="M:Expr_44_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_45">
            <exclude/>
        </member>
        <member name="M:Expr_45.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_46">
            <exclude/>
        </member>
        <member name="M:Expr_46.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_46_1">
            <exclude/>
        </member>
        <member name="M:Expr_46_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_47">
            <exclude/>
        </member>
        <member name="M:Expr_47.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_48">
            <exclude/>
        </member>
        <member name="M:Expr_48.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_48_1">
            <exclude/>
        </member>
        <member name="M:Expr_48_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_49">
            <exclude/>
        </member>
        <member name="M:Expr_49.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_50">
            <exclude/>
        </member>
        <member name="M:Expr_50.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_50_1">
            <exclude/>
        </member>
        <member name="M:Expr_50_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_51">
            <exclude/>
        </member>
        <member name="M:Expr_51.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_52">
            <exclude/>
        </member>
        <member name="M:Expr_52.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_52_1">
            <exclude/>
        </member>
        <member name="M:Expr_52_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_53">
            <exclude/>
        </member>
        <member name="M:Expr_53.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_54">
            <exclude/>
        </member>
        <member name="M:Expr_54.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_54_1">
            <exclude/>
        </member>
        <member name="M:Expr_54_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_55">
            <exclude/>
        </member>
        <member name="M:Expr_55.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_56">
            <exclude/>
        </member>
        <member name="M:Expr_56.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_56_1">
            <exclude/>
        </member>
        <member name="M:Expr_56_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_57">
            <exclude/>
        </member>
        <member name="M:Expr_57.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_58">
            <exclude/>
        </member>
        <member name="M:Expr_58.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_58_1">
            <exclude/>
        </member>
        <member name="M:Expr_58_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_59">
            <exclude/>
        </member>
        <member name="M:Expr_59.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_60">
            <exclude/>
        </member>
        <member name="M:Expr_60.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_60_1">
            <exclude/>
        </member>
        <member name="M:Expr_60_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_61">
            <exclude/>
        </member>
        <member name="M:Expr_61.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_62">
            <exclude/>
        </member>
        <member name="M:Expr_62.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_62_1">
            <exclude/>
        </member>
        <member name="M:Expr_62_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_63">
            <exclude/>
        </member>
        <member name="M:Expr_63.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_64">
            <exclude/>
        </member>
        <member name="M:Expr_64.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_64_1">
            <exclude/>
        </member>
        <member name="M:Expr_64_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_65">
            <exclude/>
        </member>
        <member name="M:Expr_65.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_66">
            <exclude/>
        </member>
        <member name="M:Expr_66.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_66_1">
            <exclude/>
        </member>
        <member name="M:Expr_66_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_67">
            <exclude/>
        </member>
        <member name="M:Expr_67.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_68">
            <exclude/>
        </member>
        <member name="M:Expr_68.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_68_1">
            <exclude/>
        </member>
        <member name="M:Expr_68_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_69">
            <exclude/>
        </member>
        <member name="M:Expr_69.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_70">
            <exclude/>
        </member>
        <member name="M:Expr_70.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_70_1">
            <exclude/>
        </member>
        <member name="M:Expr_70_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_71">
            <exclude/>
        </member>
        <member name="M:Expr_71.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_72">
            <exclude/>
        </member>
        <member name="M:Expr_72.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_72_1">
            <exclude/>
        </member>
        <member name="M:Expr_72_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_73">
            <exclude/>
        </member>
        <member name="M:Expr_73.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_74">
            <exclude/>
        </member>
        <member name="M:Expr_74.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_74_1">
            <exclude/>
        </member>
        <member name="M:Expr_74_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_75">
            <exclude/>
        </member>
        <member name="M:Expr_75.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_76">
            <exclude/>
        </member>
        <member name="M:Expr_76.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_76_1">
            <exclude/>
        </member>
        <member name="M:Expr_76_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_77">
            <exclude/>
        </member>
        <member name="M:Expr_77.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_78">
            <exclude/>
        </member>
        <member name="M:Expr_78.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Expr_78_1">
            <exclude/>
        </member>
        <member name="M:Expr_78_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group">
            <exclude/>
        </member>
        <member name="M:Group.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="P:Group.yyname">
            <exclude/>
        </member>
        <member name="P:Group.yynum">
            <exclude/>
        </member>
        <member name="T:Group_1">
            <exclude/>
        </member>
        <member name="M:Group_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_2">
            <exclude/>
        </member>
        <member name="M:Group_2.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_2_1">
            <exclude/>
        </member>
        <member name="M:Group_2_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_3">
            <exclude/>
        </member>
        <member name="M:Group_3.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_4">
            <exclude/>
        </member>
        <member name="M:Group_4.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_4_1">
            <exclude/>
        </member>
        <member name="M:Group_4_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_5">
            <exclude/>
        </member>
        <member name="M:Group_5.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_6">
            <exclude/>
        </member>
        <member name="M:Group_6.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_6_1">
            <exclude/>
        </member>
        <member name="M:Group_6_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_7">
            <exclude/>
        </member>
        <member name="M:Group_7.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_8">
            <exclude/>
        </member>
        <member name="M:Group_8.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_8_1">
            <exclude/>
        </member>
        <member name="M:Group_8_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_9">
            <exclude/>
        </member>
        <member name="M:Group_9.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_10">
            <exclude/>
        </member>
        <member name="M:Group_10.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_10_1">
            <exclude/>
        </member>
        <member name="M:Group_10_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_11">
            <exclude/>
        </member>
        <member name="M:Group_11.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_12">
            <exclude/>
        </member>
        <member name="M:Group_12.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_12_1">
            <exclude/>
        </member>
        <member name="M:Group_12_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_13">
            <exclude/>
        </member>
        <member name="M:Group_13.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_14">
            <exclude/>
        </member>
        <member name="M:Group_14.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_14_1">
            <exclude/>
        </member>
        <member name="M:Group_14_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_15">
            <exclude/>
        </member>
        <member name="M:Group_15.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_16">
            <exclude/>
        </member>
        <member name="M:Group_16.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_16_1">
            <exclude/>
        </member>
        <member name="M:Group_16_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_17">
            <exclude/>
        </member>
        <member name="M:Group_17.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_18">
            <exclude/>
        </member>
        <member name="M:Group_18.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:Group_18_1">
            <exclude/>
        </member>
        <member name="M:Group_18_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:yysyntax">
            <exclude/>
        </member>
        <member name="M:yysyntax.Action(Tools.Parser,Tools.SYMBOL,System.Int32)">
            <exclude/>
        </member>
        <member name="M:yysyntax.#ctor">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_46_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_20_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.error_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_18_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_38_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_33_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_76_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_50_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_16_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_59_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_40_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_66_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_40_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_27_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_6_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_10_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_74_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_70_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_52_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_10_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_2_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_5_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_60_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_42_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_21_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_68_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_4_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_22_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_65_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_72_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.SpecDoc_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_73_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.SpecDoc_4_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_8_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_38_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_56_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_62_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_5_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_35_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_34_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_67_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_8_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_26_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_24_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_50_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_6_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_54_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_61_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_44_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_62_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_44_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_37_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_16_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_2_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.SpecDoc_3_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_31_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_78_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_74_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_3_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.SpecDoc_4_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_14_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_32_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_75_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_64_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_17_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_43_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_8_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_26_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_69_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_9_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_32_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_77_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_13_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_76_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_39_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_20_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_18_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_6_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_71_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_28_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_72_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_12_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.SpecDoc_2_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_58_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_3_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_54_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_48_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_66_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_48_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_45_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_14_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_53_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_78_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_18_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_36_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_2_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_60_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_15_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_68_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_47_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_10_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_9_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_30_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_16_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.SpecDoc_2_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.SpecDoc_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_7_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_13_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_41_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_25_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_24_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_42_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_63_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_15_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_11_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_58_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_4_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_8_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_12_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_55_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_14_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_23_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_2_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_49_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_12_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_16_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_70_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_18_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_57_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_17_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_6_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_64_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_19_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_7_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_36_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_10_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_12_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_4_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_22_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_51_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_29_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_34_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_14_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_52_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_11_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_56_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_30_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_4_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_28_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Group_1_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:yysyntax.Expr_46_factory(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:syntax">
            <exclude/>
        </member>
        <member name="M:syntax.#ctor">
            <exclude/>
        </member>
        <member name="M:syntax.#ctor(Tools.YyParser)">
            <exclude/>
        </member>
        <member name="M:syntax.#ctor(Tools.YyParser,Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="T:YYClass.BASE">
            <exclude/>
        </member>
        <member name="P:YYClass.BASE.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.BASE.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.THIS">
            <exclude/>
        </member>
        <member name="P:YYClass.THIS.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.THIS.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.NEW">
            <exclude/>
        </member>
        <member name="P:YYClass.NEW.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.NEW.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.ID">
            <exclude/>
        </member>
        <member name="P:YYClass.ID.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.ID.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.ANY">
            <exclude/>
        </member>
        <member name="P:YYClass.ANY.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.ANY.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.COLON">
            <exclude/>
        </member>
        <member name="P:YYClass.COLON.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.COLON.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.SEMICOLON">
            <exclude/>
        </member>
        <member name="P:YYClass.SEMICOLON.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.SEMICOLON.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.LBRACE">
            <exclude/>
        </member>
        <member name="P:YYClass.LBRACE.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.LBRACE.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.RBRACE">
            <exclude/>
        </member>
        <member name="P:YYClass.RBRACE.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.RBRACE.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.LPAREN">
            <exclude/>
        </member>
        <member name="P:YYClass.LPAREN.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.LPAREN.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.RPAREN">
            <exclude/>
        </member>
        <member name="P:YYClass.RPAREN.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.RPAREN.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.LBRACK">
            <exclude/>
        </member>
        <member name="P:YYClass.LBRACK.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.LBRACK.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.RBRACK">
            <exclude/>
        </member>
        <member name="P:YYClass.RBRACK.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.RBRACK.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.yycs0tokens">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.THIS_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.LBRACK_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.ID_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.LPAREN_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.RPAREN_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.COLON_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.NEW_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.SEMICOLON_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.LBRACE_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.ANY_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.RBRACK_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.RBRACE_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.BASE_factory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0tokens.OldAction(Tools.Lexer,System.String@,System.Int32,System.Boolean@)">
            <exclude/>
        </member>
        <member name="T:YYClass.cs0tokens">
            <exclude/>
        </member>
        <member name="M:YYClass.cs0tokens.#ctor">
            <exclude/>
        </member>
        <member name="M:YYClass.cs0tokens.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="M:YYClass.cs0tokens.#ctor(Tools.YyLexer)">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff">
            <exclude/>
        </member>
        <member name="P:YYClass.GStuff.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.GStuff.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.GStuff.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.Stuff">
            <exclude/>
        </member>
        <member name="P:YYClass.Stuff.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.Stuff.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.Stuff.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.Item">
            <exclude/>
        </member>
        <member name="P:YYClass.Item.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.Item.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.Item.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.ClassBody">
            <exclude/>
        </member>
        <member name="P:YYClass.ClassBody.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.ClassBody.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.ClassBody.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.Cons">
            <exclude/>
        </member>
        <member name="P:YYClass.Cons.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.Cons.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.Cons.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.Call">
            <exclude/>
        </member>
        <member name="P:YYClass.Call.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.Call.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.Call.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall">
            <exclude/>
        </member>
        <member name="P:YYClass.BaseCall.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.BaseCall.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.BaseCall.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.Name">
            <exclude/>
        </member>
        <member name="P:YYClass.Name.yyname">
            <exclude/>
        </member>
        <member name="P:YYClass.Name.yynum">
            <exclude/>
        </member>
        <member name="M:YYClass.Name.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.ClassBody_1">
            <exclude/>
        </member>
        <member name="M:YYClass.ClassBody_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.ClassBody_2">
            <exclude/>
        </member>
        <member name="M:YYClass.ClassBody_2.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.ClassBody_2_1">
            <exclude/>
        </member>
        <member name="M:YYClass.ClassBody_2_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_1">
            <exclude/>
        </member>
        <member name="M:YYClass.GStuff_1.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_2">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_2_1">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_3">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_4">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_4_1">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_5">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_6">
            <exclude/>
        </member>
        <member name="T:YYClass.GStuff_6_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Stuff_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Stuff_2">
            <exclude/>
        </member>
        <member name="T:YYClass.Stuff_2_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Stuff_3">
            <exclude/>
        </member>
        <member name="T:YYClass.Stuff_4">
            <exclude/>
        </member>
        <member name="T:YYClass.Stuff_4_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Cons_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Cons_2">
            <exclude/>
        </member>
        <member name="T:YYClass.Cons_2_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Call_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Call_2">
            <exclude/>
        </member>
        <member name="T:YYClass.Call_2_1">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_1">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_2">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_2_1">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_3">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_4">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_4_1">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_5">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_6">
            <exclude/>
        </member>
        <member name="T:YYClass.BaseCall_6_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Name_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Name_2">
            <exclude/>
        </member>
        <member name="T:YYClass.Name_2_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Name_3">
            <exclude/>
        </member>
        <member name="T:YYClass.Name_4">
            <exclude/>
        </member>
        <member name="T:YYClass.Name_4_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_2">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_2_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_3">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_4">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_4_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_5">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_6">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_6_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_7">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_8">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_8_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_9">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_10">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_10_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_11">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_12">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_12_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_13">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_14">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_14_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_15">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_16">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_16_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_17">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_18">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_18_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_19">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_20">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_20_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_21">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_22">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_22_1">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_23">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_24">
            <exclude/>
        </member>
        <member name="T:YYClass.Item_24_1">
            <exclude/>
        </member>
        <member name="T:YYClass.yycs0syntax">
            <exclude/>
        </member>
        <member name="M:YYClass.yycs0syntax.#ctor">
            <exclude/>
        </member>
        <member name="T:YYClass.cs0syntax">
            <exclude/>
        </member>
        <member name="T:Tools.LNode">
            <exclude/>
        </member>
        <member name="F:Tools.LNode.m_state">
            <exclude/>
        </member>
        <member name="F:Tools.LNode.m_tks">
            <exclude/>
        </member>
        <member name="M:Tools.LNode.#ctor(Tools.TokensGen)">
            <exclude/>
        </member>
        <member name="M:Tools.LNode.#ctor">
            <exclude/>
        </member>
        <member name="T:Tools.TokClassDef">
            <exclude/>
        </member>
        <member name="F:Tools.TokClassDef.m_refToken">
            <exclude/>
        </member>
        <member name="F:Tools.TokClassDef.m_initialisation">
            <exclude/>
        </member>
        <member name="F:Tools.TokClassDef.m_implement">
            <exclude/>
        </member>
        <member name="M:Tools.TokClassDef.#ctor(Tools.GenBase,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.TokClassDef.#ctor">
            <exclude/>
        </member>
        <member name="F:Tools.TokClassDef.m_name">
            <exclude/>
        </member>
        <member name="F:Tools.TokClassDef.m_yynum">
            <exclude/>
        </member>
        <member name="M:Tools.TokClassDef.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.Dfa">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.#ctor(Tools.TokensGen)">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.m_tokens">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.SetTokens(Tools.YyLexer,System.Collections.Hashtable)">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.m_map">
            <exclude/>
        </member>
        <member name="T:Tools.Dfa.Action">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.Action.a_act">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.Action.a_next">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.Action.#ctor(System.Int32,Tools.Dfa.Action)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.Action.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.m_tokClass">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.m_actions">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.m_reswds">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.AddAction(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.MakeLastAction(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.#ctor(Tools.Nfa)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.AddNfaNode(Tools.NfaNode)">
            <exclude/>
        </member>
        <member name="F:Tools.Dfa.m_nfa">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.AddActions">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.Target(System.Char)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.Closure">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.ClosureAdd(Tools.NfaNode)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.SameAs(Tools.Dfa)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.Match(System.String,System.Int32,System.Int32@)">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.Print">
            <exclude/>
        </member>
        <member name="M:Tools.Dfa.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.Regex">
            <exclude/>
        </member>
        <member name="M:Tools.Regex.#ctor(Tools.TokensGen,System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.Regex.#ctor">
            <exclude/>
        </member>
        <member name="F:Tools.Regex.m_sub">
            <exclude/>
        </member>
        <member name="M:Tools.Regex.Print(System.IO.TextWriter)">
            <exclude/>
        </member>
        <member name="M:Tools.Regex.Match(System.Char)">
            <exclude/>
        </member>
        <member name="M:Tools.Regex.Match(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.Regex.Match(System.String,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Regex.Build(Tools.Nfa)">
            <exclude/>
        </member>
        <member name="T:Tools.ReAlt">
            <exclude/>
        </member>
        <member name="M:Tools.ReAlt.Match(System.String,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.ReAlt.Build(Tools.Nfa)">
            <exclude/>
        </member>
        <member name="T:Tools.ReCat">
            <exclude/>
        </member>
        <member name="M:Tools.ReCat.#ctor(Tools.TokensGen,Tools.Regex,System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="F:Tools.ReCat.m_next">
            <exclude/>
        </member>
        <member name="M:Tools.ReCat.Print(System.IO.TextWriter)">
            <exclude/>
        </member>
        <member name="M:Tools.ReCat.Match(System.String,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.ReCat.Build(Tools.Nfa)">
            <exclude/>
        </member>
        <member name="T:Tools.ReStr">
            <exclude/>
        </member>
        <member name="M:Tools.ReStr.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.ReStr.#ctor(Tools.TokensGen,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.ReStr.#ctor(Tools.TokensGen,System.Char)">
            <exclude/>
        </member>
        <member name="F:Tools.ReStr.m_str">
            <exclude/>
        </member>
        <member name="M:Tools.ReStr.Print(System.IO.TextWriter)">
            <exclude/>
        </member>
        <member name="M:Tools.ReStr.Match(System.String,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.ReStr.Build(Tools.Nfa)">
            <exclude/>
        </member>
        <member name="T:Tools.ReUStr">
            <exclude/>
        </member>
        <member name="M:Tools.ReUStr.#ctor(Tools.TokensGen,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.ReUStr.#ctor(Tools.TokensGen,System.Char)">
            <exclude/>
        </member>
        <member name="M:Tools.ReUStr.Print(System.IO.TextWriter)">
            <exclude/>
        </member>
        <member name="M:Tools.ReUStr.Match(System.String,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="T:Tools.NfaNode">
            <exclude/>
        </member>
        <member name="F:Tools.NfaNode.m_sTerminal">
            <exclude/>
        </member>
        <member name="F:Tools.NfaNode.m_arcs">
            <exclude/>
        </member>
        <member name="F:Tools.NfaNode.m_eps">
            <exclude/>
        </member>
        <member name="M:Tools.NfaNode.#ctor(Tools.TokensGen)">
            <exclude/>
        </member>
        <member name="M:Tools.NfaNode.AddArc(System.Char,Tools.NfaNode)">
            <exclude/>
        </member>
        <member name="M:Tools.NfaNode.AddUArc(System.Char,Tools.NfaNode)">
            <exclude/>
        </member>
        <member name="M:Tools.NfaNode.AddArcEx(Tools.Regex,Tools.NfaNode)">
            <exclude/>
        </member>
        <member name="M:Tools.NfaNode.AddEps(Tools.NfaNode)">
            <exclude/>
        </member>
        <member name="M:Tools.NfaNode.AddTarget(System.Char,Tools.Dfa)">
            <exclude/>
        </member>
        <member name="T:Tools.Nfa">
            <exclude/>
        </member>
        <member name="F:Tools.Nfa.m_end">
            <exclude/>
        </member>
        <member name="M:Tools.Nfa.#ctor(Tools.TokensGen)">
            <exclude/>
        </member>
        <member name="M:Tools.Nfa.#ctor(Tools.TokensGen,Tools.Regex)">
            <exclude/>
        </member>
        <member name="T:Tools.ResWds">
            <exclude/>
        </member>
        <member name="F:Tools.ResWds.m_upper">
            <exclude/>
        </member>
        <member name="F:Tools.ResWds.m_wds">
            <exclude/>
        </member>
        <member name="M:Tools.ResWds.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.ResWds.New(Tools.TokensGen,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.ResWds.Check(Tools.Lexer,Tools.TOKEN@)">
            <exclude/>
        </member>
        <member name="M:Tools.ResWds.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.GenBase">
            <exclude/>
        </member>
        <member name="F:Tools.GenBase.erh">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="F:Tools.GenBase.m_outFile">
            <exclude/>
        </member>
        <member name="F:Tools.GenBase.m_scriptEncoding">
            <exclude/>
        </member>
        <member name="F:Tools.GenBase.toupper">
            <exclude/>
        </member>
        <member name="P:Tools.GenBase.ScriptEncoding">
            <exclude/>
        </member>
        <member name="F:Tools.GenBase.m_outname">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.Braces(System.Int32,System.String,System.Int32@,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.ToBraceIfFound(System.String@,System.Int32@,System.Int32@,Tools.CsReader)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.White(System.String,System.Int32@,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.NonWhite(System.String,System.Int32@,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.EmitClassDefin(System.String,System.Int32@,System.Int32,Tools.CsReader,System.String,System.String@,System.String@,System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.Error(System.Int32,System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.sourceLineInfo(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.line(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.position(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.GenBase.Saypos(System.Int32)">
            <exclude/>
        </member>
        <member name="F:Tools.GenBase.m_prod">
            <exclude/>
        </member>
        <member name="F:Tools.GenBase.LastSymbol">
            <exclude/>
        </member>
        <member name="T:Tools.YyLexer">
            <exclude/>
        </member>
        <member name="M:Tools.YyLexer.GetDfa">
            <exclude/>
        </member>
        <member name="M:Tools.YyLexer.EmitDfa(System.IO.TextWriter)">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.m_encoding">
            <exclude/>
        </member>
        <member name="P:Tools.YyLexer.InputEncoding">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.usingEOF">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.toupper">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.cats">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.m_gencat">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.starts">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.arr">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.types">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.tokens">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.reswds">
            <exclude/>
        </member>
        <member name="F:Tools.YyLexer.erh">
            <exclude/>
        </member>
        <member name="M:Tools.YyLexer.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="M:Tools.YyLexer.Tokenfactory(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:Tools.YyLexer.UsingCat(System.Globalization.UnicodeCategory)">
            <exclude/>
        </member>
        <member name="M:Tools.YyLexer.OldAction(Tools.Lexer,System.String@,System.Int32,System.Boolean@)">
            <exclude/>
        </member>
        <member name="M:Tools.YyLexer.GetEnumerator">
            <exclude/>
        </member>
        <member name="T:Tools.LineManager">
            <exclude/>
        </member>
        <member name="F:Tools.LineManager.lines">
            <exclude/>
        </member>
        <member name="F:Tools.LineManager.end">
            <exclude/>
        </member>
        <member name="F:Tools.LineManager.list">
            <exclude/>
        </member>
        <member name="M:Tools.LineManager.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.LineManager.newline(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.LineManager.backto(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.LineManager.comment(System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="T:Tools.TokensGen">
            <exclude/>
        </member>
        <member name="M:Tools.TokensGen.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="F:Tools.TokensGen.m_showDfa">
            <exclude/>
        </member>
        <member name="F:Tools.TokensGen.m_tokens">
            <exclude/>
        </member>
        <member name="F:Tools.TokensGen.defines">
            <exclude/>
        </member>
        <member name="F:Tools.TokensGen.state">
            <exclude/>
        </member>
        <member name="M:Tools.TokensGen.NewState">
            <exclude/>
        </member>
        <member name="F:Tools.TokensGen.states">
            <exclude/>
        </member>
        <member name="M:Tools.TokensGen.FixActions(System.String)">
            <exclude/>
        </member>
        <member name="T:Tools.CatTest">
            <exclude/>
        </member>
        <member name="M:Tools.CatTest.#ctor(System.Globalization.UnicodeCategory)">
            <exclude/>
        </member>
        <member name="M:Tools.CatTest.Test(System.Char)">
            <exclude/>
        </member>
        <member name="T:Tools.Charset">
            <exclude/>
        </member>
        <member name="M:Tools.Charset.GetEncoding(System.String,System.Boolean@,Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="M:Tools.Charset.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.TCreator">
            <exclude/>
        </member>
        <member name="T:Tools.Tfactory">
            <exclude/>
        </member>
        <member name="M:Tools.Tfactory.create(System.String,Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:Tools.Tfactory.#ctor(Tools.YyLexer,System.String,Tools.TCreator)">
            <exclude/>
        </member>
        <member name="T:Tools.SourceLineInfo">
            <exclude/>
        </member>
        <member name="F:Tools.SourceLineInfo.lineNumber">
            <exclude/>
        </member>
        <member name="F:Tools.SourceLineInfo.charPosition">
            <exclude/>
        </member>
        <member name="F:Tools.SourceLineInfo.startOfLine">
            <exclude/>
        </member>
        <member name="F:Tools.SourceLineInfo.endOfLine">
            <exclude/>
        </member>
        <member name="F:Tools.SourceLineInfo.rawCharPosition">
            <exclude/>
        </member>
        <member name="F:Tools.SourceLineInfo.lxr">
            <exclude/>
        </member>
        <member name="M:Tools.SourceLineInfo.#ctor(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.SourceLineInfo.#ctor(Tools.LineManager,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.SourceLineInfo.#ctor(Tools.Lexer,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.SourceLineInfo.ToString">
            <exclude/>
        </member>
        <member name="P:Tools.SourceLineInfo.sourceLine">
            <exclude/>
        </member>
        <member name="T:Tools.LineList">
            <exclude/>
        </member>
        <member name="F:Tools.LineList.head">
            <exclude/>
        </member>
        <member name="F:Tools.LineList.comments">
            <exclude/>
        </member>
        <member name="F:Tools.LineList.tail">
            <exclude/>
        </member>
        <member name="M:Tools.LineList.#ctor(System.Int32,Tools.LineList)">
            <exclude/>
        </member>
        <member name="M:Tools.LineList.getpos(System.Int32)">
            <exclude/>
        </member>
        <member name="T:Tools.CommentList">
            <exclude/>
        </member>
        <member name="F:Tools.CommentList.spos">
            <exclude/>
        </member>
        <member name="F:Tools.CommentList.len">
            <exclude/>
        </member>
        <member name="F:Tools.CommentList.tail">
            <exclude/>
        </member>
        <member name="M:Tools.CommentList.#ctor(System.Int32,System.Int32,Tools.CommentList)">
            <exclude/>
        </member>
        <member name="T:Tools.CsReader">
            <exclude/>
        </member>
        <member name="F:Tools.CsReader.fname">
            <exclude/>
        </member>
        <member name="F:Tools.CsReader.lm">
            <exclude/>
        </member>
        <member name="M:Tools.CsReader.#ctor(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CsReader.#ctor(System.String,System.Text.Encoding)">
            <exclude/>
        </member>
        <member name="M:Tools.CsReader.#ctor(Tools.CsReader,System.Text.Encoding)">
            <exclude/>
        </member>
        <member name="M:Tools.CsReader.Eof">
            <exclude/>
        </member>
        <member name="M:Tools.CsReader.Read(System.Char[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.CsReader.ReadLine">
            <exclude/>
        </member>
        <member name="M:Tools.CsReader.Read">
            <exclude/>
        </member>
        <member name="T:Tools.SYMBOL">
            <exclude/>
        </member>
        <member name="F:Tools.SYMBOL.m_dollar">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.op_Implicit(Tools.SYMBOL)~System.Int32">
            <exclude/>
        </member>
        <member name="F:Tools.SYMBOL.pos">
            <exclude/>			
        </member>
        <member name="P:Tools.SYMBOL.Line">
            <exclude/>
        </member>
        <member name="P:Tools.SYMBOL.Position">
            <exclude/>
        </member>
        <member name="P:Tools.SYMBOL.Pos">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.#ctor">
            <exclude/>
        </member>
        <member name="F:Tools.SYMBOL.yylx">
            <exclude/>
        </member>
        <member name="P:Tools.SYMBOL.yylval">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="P:Tools.SYMBOL.yynum">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.IsTerminal">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.IsAction">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.IsCSymbol">
            <exclude/>
        </member>
        <member name="F:Tools.SYMBOL.yyps">
            <exclude/>
        </member>
        <member name="P:Tools.SYMBOL.yyact">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.Pass(Tools.YyParser,System.Int32,Tools.ParserEntry@)">
            <exclude/>
        </member>
        <member name="P:Tools.SYMBOL.yyname">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.ToString">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.Matches(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.Print">
            <exclude/>
        </member>
        <member name="F:Tools.SYMBOL.kids">
            <exclude/>
        </member>
        <member name="M:Tools.SYMBOL.ConcreteSyntaxTree">
            <exclude/>
        </member>
        <member name="T:Tools.TOKEN">
            <exclude/>
        </member>
        <member name="P:Tools.TOKEN.yytext">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.#ctor(Tools.Lexer,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.IsTerminal">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.Pass(Tools.YyParser,System.Int32,Tools.ParserEntry@)">
            <exclude/>
        </member>
        <member name="P:Tools.TOKEN.yyname">
            <exclude/>
        </member>
        <member name="P:Tools.TOKEN.yynum">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.Matches(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.ToString">
            <exclude/>
        </member>
        <member name="M:Tools.TOKEN.Print">
            <exclude/>
        </member>
        <member name="T:Tools.Lexer">
            <exclude/>
        </member>
        <member name="F:Tools.Lexer.m_debug">
            <exclude/>
        </member>
        <member name="F:Tools.Lexer.m_buf">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.sourceLineInfo(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.sourceLine(Tools.SourceLineInfo)">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.Saypos(System.Int32)">
            <exclude/>
        </member>
        <member name="P:Tools.Lexer.m_start">
            <exclude/>
        </member>
        <member name="F:Tools.Lexer.m_state">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.#ctor(Tools.YyLexer)">
            <exclude/>
        </member>
        <member name="P:Tools.Lexer.tokens">
            <exclude/>
        </member>
        <member name="F:Tools.Lexer.yytext">
            <exclude/>
        </member>
        <member name="F:Tools.Lexer.m_pch">
            <exclude/>
        </member>
        <member name="P:Tools.Lexer.yypos">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.yy_begin(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.Start(System.IO.StreamReader)">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.Start(Tools.CsReader)">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.Start(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.Next">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.PeekChar">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.Advance">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.GetChar">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.UnGetChar">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.GetEnumerator">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer.Reset">
            <exclude/>
        </member>
        <member name="T:Tools.Lexer._Enumerator">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer._Enumerator.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer._Enumerator.MoveNext">
            <exclude/>
        </member>
        <member name="P:Tools.Lexer._Enumerator.Current">
            <exclude/>
        </member>
        <member name="M:Tools.Lexer._Enumerator.Reset">
            <exclude/>
        </member>
        <member name="T:Tools.CSToolsException">
            <exclude/>
        </member>
        <member name="F:Tools.CSToolsException.nExceptionNumber">
            <exclude/>
        </member>
        <member name="F:Tools.CSToolsException.slInfo">
            <exclude/>
        </member>
        <member name="F:Tools.CSToolsException.sInput">
            <exclude/>
        </member>
        <member name="F:Tools.CSToolsException.sym">
            <exclude/>
        </member>
        <member name="F:Tools.CSToolsException.handled">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.#ctor(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.#ctor(System.Int32,Tools.Lexer,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.#ctor(System.Int32,Tools.Lexer,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.#ctor(System.Int32,Tools.TOKEN,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.#ctor(System.Int32,Tools.SYMBOL,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.#ctor(System.Int32,Tools.Lexer,System.Int32,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.#ctor(System.Int32,Tools.SourceLineInfo,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsException.Handle(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="T:Tools.CSToolsFatalException">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsFatalException.#ctor(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsFatalException.#ctor(System.Int32,Tools.Lexer,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsFatalException.#ctor(System.Int32,Tools.Lexer,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsFatalException.#ctor(System.Int32,Tools.Lexer,System.Int32,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsFatalException.#ctor(System.Int32,Tools.TOKEN,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsFatalException.#ctor(System.Int32,Tools.SourceLineInfo,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsFatalException.Handle(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="T:Tools.CSToolsStopException">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.#ctor(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.#ctor(System.Int32,Tools.Lexer,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.#ctor(System.Int32,Tools.Lexer,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.#ctor(System.Int32,Tools.Lexer,System.Int32,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.#ctor(System.Int32,Tools.TOKEN,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.#ctor(System.Int32,Tools.SYMBOL,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.#ctor(System.Int32,Tools.SourceLineInfo,System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSToolsStopException.Handle(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="T:Tools.ErrorHandler">
            <exclude/>
        </member>
        <member name="F:Tools.ErrorHandler.counter">
            <exclude/>
        </member>
        <member name="F:Tools.ErrorHandler.throwExceptions">
            <exclude/>
        </member>
        <member name="M:Tools.ErrorHandler.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.ErrorHandler.#ctor(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Tools.ErrorHandler.Error(Tools.CSToolsException)">
            <exclude/>
        </member>
        <member name="M:Tools.ErrorHandler.Report(Tools.CSToolsException)">
            <exclude/>
        </member>
        <member name="T:Tools.YyParser">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.erh">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.#ctor">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.symbols">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.literals">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.symbolInfo">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.m_concrete">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.m_states">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.EOFSymbol">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.Special">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.m_startSymbol">
            <exclude/>
        </member>
        <member name="P:Tools.YyParser.StartSymbol">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.GetSymbolInfo(System.String,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.ClassInit(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.Transitions(Tools.Builder)">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.PrintTransitions(Tools.Func,System.String)">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.m_accept">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.Action(Tools.Parser,Tools.SYMBOL,System.Int32)">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.types">
            <exclude/>
        </member>
        <member name="F:Tools.YyParser.arr">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.GetEOF(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.Emit(System.IO.TextWriter)">
            <exclude/>
        </member>
        <member name="M:Tools.YyParser.GetParser(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="T:Tools.SymbolsGen">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.#ctor(Tools.ErrorHandler)">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.m_lalrParser">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.m_lexer">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.m_symbols">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.pno">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.prods">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.m_trans">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.action">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.action_num">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.stypes">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.state">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolsGen.lahead">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.Find(Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.ParserDirective">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.Declare">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.SetNamespace">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.SetStartSymbol">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.ClassDefinition(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.AssocType(Tools.Precedence.PrecType,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.CopySegment">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.SimpleAction(Tools.ParserSimpleAction)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolsGen.OldAction(Tools.ParserOldAction)">
            <exclude/>
        </member>
        <member name="T:Tools.SymbolType">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolType.#ctor(Tools.SymbolsGen,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolType.#ctor(Tools.SymbolsGen,System.String,System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolType._Find(System.String)">
            <exclude/>
        </member>
        <member name="T:Tools.ParserAction">
            <exclude/>
        </member>
        <member name="M:Tools.ParserAction.Action(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserAction.Print">
            <exclude/>
        </member>
        <member name="F:Tools.ParserAction.m_sym">
            <exclude/>
        </member>
        <member name="F:Tools.ParserAction.m_len">
            <exclude/>
        </member>
        <member name="M:Tools.ParserAction.IsAction">
            <exclude/>
        </member>
        <member name="M:Tools.ParserAction.ActNum">
            <exclude/>
        </member>
        <member name="M:Tools.ParserAction.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserAction.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.ParserAction.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.ParserOldAction">
            <exclude/>
        </member>
        <member name="F:Tools.ParserOldAction.m_action">
            <exclude/>
        </member>
        <member name="M:Tools.ParserOldAction.Action(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserOldAction.ActNum">
            <exclude/>
        </member>
        <member name="M:Tools.ParserOldAction.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserOldAction.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.ParserSimpleAction">
            <exclude/>
        </member>
        <member name="M:Tools.ParserSimpleAction.TypeStr">
            <exclude/>
        </member>
        <member name="M:Tools.ParserSimpleAction.Print">
            <exclude/>
        </member>
        <member name="M:Tools.ParserSimpleAction.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserSimpleAction.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.ParserEntry">
            <exclude/>
        </member>
        <member name="F:Tools.ParserEntry.m_action">
            <exclude/>
        </member>
        <member name="F:Tools.ParserEntry.m_priority">
            <exclude/>
        </member>
        <member name="M:Tools.ParserEntry.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.ParserEntry.#ctor(Tools.ParserAction)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserEntry.Pass(Tools.ParseStackEntry@)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserEntry.IsReduce">
            <exclude/>
        </member>
        <member name="P:Tools.ParserEntry.str">
            <exclude/>
        </member>
        <member name="M:Tools.ParserEntry.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.ParserShift">
            <exclude/>
        </member>
        <member name="F:Tools.ParserShift.m_next">
            <exclude/>
        </member>
        <member name="M:Tools.ParserShift.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.ParserShift.#ctor(Tools.ParserAction,Tools.ParseState)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserShift.Pass(Tools.ParseStackEntry@)">
            <exclude/>
        </member>
        <member name="P:Tools.ParserShift.str">
            <exclude/>
        </member>
        <member name="M:Tools.ParserShift.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.ParserReduce">
            <exclude/>
        </member>
        <member name="F:Tools.ParserReduce.m_depth">
            <exclude/>
        </member>
        <member name="F:Tools.ParserReduce.m_prod">
            <exclude/>
        </member>
        <member name="M:Tools.ParserReduce.#ctor(Tools.ParserAction,System.Int32,Tools.Production)">
            <exclude/>
        </member>
        <member name="F:Tools.ParserReduce.m_lookAhead">
            <exclude/>
        </member>
        <member name="M:Tools.ParserReduce.BuildLookback(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserReduce.Pass(Tools.ParseStackEntry@)">
            <exclude/>
        </member>
        <member name="M:Tools.ParserReduce.IsReduce">
            <exclude/>
        </member>
        <member name="P:Tools.ParserReduce.str">
            <exclude/>
        </member>
        <member name="M:Tools.ParserReduce.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.Relation">
            <exclude/>
        </member>
        <member name="T:Tools.Func">
            <exclude/>
        </member>
        <member name="T:Tools.AddToFunc">
            <exclude/>
        </member>
        <member name="T:Tools.Builder">
            <exclude/>
        </member>
        <member name="T:Tools.Transition">
            <exclude/>
        </member>
        <member name="F:Tools.Transition.m_tno">
            <exclude/>
        </member>
        <member name="F:Tools.Transition.m_ps">
            <exclude/>
        </member>
        <member name="F:Tools.Transition.m_A">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.#ctor(Tools.ParseState,Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="F:Tools.Transition.m_next">
            <exclude/>
        </member>
        <member name="F:Tools.Transition.m_reduce">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.reads(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.includes(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.DR(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.Read(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.Follow(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.AddToRead(Tools.Transition,Tools.SymbolSet)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.AddToFollow(Tools.Transition,Tools.SymbolSet)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.BuildDR(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.Final(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.BuildReads(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.BuildIncludes(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.BuildLookback(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.BuildLA(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.BuildParseTable(Tools.Transition)">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.Print0">
            <exclude/>
        </member>
        <member name="M:Tools.Transition.Print(Tools.SymbolSet,System.String)">
            <exclude/>
        </member>
        <member name="T:Tools.ParseState">
            <exclude/>
        </member>
        <member name="F:Tools.ParseState.m_state">
            <exclude/>
        </member>
        <member name="F:Tools.ParseState.m_accessingSymbol">
            <exclude/>
        </member>
        <member name="F:Tools.ParseState.m_sgen">
            <exclude/>
        </member>
        <member name="F:Tools.ParseState.m_items">
            <exclude/>
        </member>
        <member name="F:Tools.ParseState.m_transitions">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.GetTransition(Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.Accessor(Tools.CSymbol[])">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.Lookback(Tools.Production,Tools.ParseState)">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.MaybeAdd(Tools.ProdItem)">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.Closure">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.CheckClosure(Tools.ProdItem)">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.AddEntries">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.ReduceStates">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.SameAs(Tools.ParseState)">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.CheckExists">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.Finalize">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.#ctor(Tools.SymbolsGen,Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.Print">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.Print0">
            <exclude/>
        </member>
        <member name="M:Tools.ParseState.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.ParseStackEntry">
            <exclude/>
        </member>
        <member name="F:Tools.ParseStackEntry.yyps">
            <exclude/>
        </member>
        <member name="F:Tools.ParseStackEntry.m_state">
            <exclude/>
        </member>
        <member name="F:Tools.ParseStackEntry.m_value">
            <exclude/>
        </member>
        <member name="M:Tools.ParseStackEntry.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:Tools.ParseStackEntry.#ctor(Tools.Parser,System.Int32,Tools.SYMBOL)">
            <exclude/>
        </member>
        <member name="T:Tools.ParsingInfo">
            <exclude/>
        </member>
        <member name="F:Tools.ParsingInfo.m_name">
            <exclude/>
        </member>
        <member name="F:Tools.ParsingInfo.m_yynum">
            <exclude/>
        </member>
        <member name="F:Tools.ParsingInfo.m_parsetable">
            <exclude/>
        </member>
        <member name="M:Tools.ParsingInfo.#ctor(System.String,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.ParsingInfo.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.SymbolSet">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolSet.m_symbols">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolSet.m_next">
            <exclude/>
        </member>
        <member name="F:Tools.SymbolSet.m_set">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.#ctor(Tools.SymbolSet)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.Contains(Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="P:Tools.SymbolSet.Keys">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.GetEnumerator">
            <exclude/>
        </member>
        <member name="P:Tools.SymbolSet.Count">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.CheckIn(Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.Resolve">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.AddIn(Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.Add(Tools.SymbolSet)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.op_Addition(Tools.SymbolSet,Tools.SymbolSet)">
            <exclude/>
        </member>
        <member name="M:Tools.SymbolSet.Print">
            <exclude/>
        </member>
        <member name="T:Tools.Path">
            <exclude/>
        </member>
        <member name="F:Tools.Path.valid">
            <exclude/>
        </member>
        <member name="M:Tools.Path.#ctor(Tools.ParseState[])">
            <exclude/>
        </member>
        <member name="M:Tools.Path.#ctor(Tools.ParseState,Tools.CSymbol[])">
            <exclude/>
        </member>
        <member name="M:Tools.Path.#ctor(Tools.CSymbol[])">
            <exclude/>
        </member>
        <member name="P:Tools.Path.Spelling">
            <exclude/>
        </member>
        <member name="P:Tools.Path.Top">
            <exclude/>
        </member>
        <member name="T:Tools.Precedence">
            <exclude/>
        </member>
        <member name="T:Tools.Precedence.PrecType">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.PrecType.left">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.PrecType.right">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.PrecType.nonassoc">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.PrecType.before">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.PrecType.after">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.m_type">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.m_prec">
            <exclude/>
        </member>
        <member name="F:Tools.Precedence.m_next">
            <exclude/>
        </member>
        <member name="M:Tools.Precedence.#ctor(Tools.Precedence.PrecType,System.Int32,Tools.Precedence)">
            <exclude/>
        </member>
        <member name="M:Tools.Precedence.Check(Tools.Precedence,Tools.Precedence.PrecType,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Precedence.Check(Tools.CSymbol,Tools.Production,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Precedence.Check(Tools.Production)">
            <exclude/>
        </member>
        <member name="T:Tools.CSymbol">
            <exclude/>
        </member>
        <member name="T:Tools.CSymbol.SymType">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.SymType.unknown">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.SymType.terminal">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.SymType.nonterminal">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.SymType.nodesymbol">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.SymType.oldaction">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.SymType.simpleaction">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.SymType.eofsymbol">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_symtype">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.IsTerminal">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_yynum">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_parser">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.Resolve">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.Matches(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.TypeStr">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_prec">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.ShiftPrecedence(Tools.Production,Tools.ParseState)">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_first">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_follow">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.AddFollow(Tools.SymbolSet)">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_prods">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.AddStartItems(Tools.ParseState,Tools.SymbolSet)">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.IsNullable">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_refSymbol">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_initialisation">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_defined">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_emitted">
            <exclude/>
        </member>
        <member name="F:Tools.CSymbol.m_prod">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.#ctor">
            <exclude/>
        </member>
        <member name="M:Tools.CSymbol.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.Literal">
            <exclude/>
        </member>
        <member name="M:Tools.Literal.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.Literal.Resolve">
            <exclude/>
        </member>
        <member name="M:Tools.Literal.CouldStart(Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="M:Tools.Literal.TypeStr">
            <exclude/>
        </member>
        <member name="M:Tools.Literal.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.Production">
            <exclude/>
        </member>
        <member name="F:Tools.Production.m_pno">
            <exclude/>
        </member>
        <member name="F:Tools.Production.m_lhs">
            <exclude/>
        </member>
        <member name="F:Tools.Production.m_actionsOnly">
            <exclude/>
        </member>
        <member name="F:Tools.Production.m_prec">
            <exclude/>
        </member>
        <member name="M:Tools.Production.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.Production.#ctor(Tools.SymbolsGen,Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="F:Tools.Production.m_rhs">
            <exclude/>
        </member>
        <member name="F:Tools.Production.m_alias">
            <exclude/>
        </member>
        <member name="M:Tools.Production.AddToRhs(Tools.CSymbol)">
            <exclude/>
        </member>
        <member name="M:Tools.Production.AddFirst(Tools.CSymbol,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Production.CouldBeEmpty(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Production.Prefix(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Production.StackRef(System.String@,System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Production.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.ProdItem">
            <exclude/>
        </member>
        <member name="M:Tools.ProdItem.#ctor(Tools.Production,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.ProdItem.#ctor">
            <exclude/>
        </member>
        <member name="F:Tools.ProdItem.m_prod">
            <exclude/>
        </member>
        <member name="F:Tools.ProdItem.m_pos">
            <exclude/>
        </member>
        <member name="F:Tools.ProdItem.m_done">
            <exclude/>
        </member>
        <member name="M:Tools.ProdItem.Next">
            <exclude/>
        </member>
        <member name="M:Tools.ProdItem.IsReducingAction">
            <exclude/>
        </member>
        <member name="M:Tools.ProdItem.FirstOfRest(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.ProdItem.Print">
            <exclude/>
        </member>
        <member name="T:Tools.Parser">
            <exclude/>
        </member>
        <member name="F:Tools.Parser.m_symbols">
            <exclude/>
        </member>
        <member name="F:Tools.Parser.m_debug">
            <exclude/>
        </member>
        <member name="F:Tools.Parser.m_stkdebug">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.#ctor(Tools.YyParser,Tools.Lexer)">
            <exclude/>
        </member>
        <member name="F:Tools.Parser.m_lexer">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.Error(Tools.ParseStackEntry@,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.Parse(System.IO.StreamReader)">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.Parse(Tools.CsReader)">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.Parse(System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.StackAt(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.NextSym">
            <exclude/>
        </member>
        <member name="M:Tools.Parser.Error(System.Int32,Tools.SYMBOL,System.String)">
            <exclude/>
        </member>
        <member name="T:Tools.error">
            <exclude/>
        </member>
        <member name="F:Tools.error.state">
            <exclude/>
        </member>
        <member name="F:Tools.error.sym">
            <exclude/>
        </member>
        <member name="M:Tools.error.#ctor(Tools.Parser,Tools.ParseStackEntry)">
            <exclude/>
        </member>
        <member name="M:Tools.error.#ctor(Tools.Parser)">
            <exclude/>
        </member>
        <member name="P:Tools.error.yyname">
            <exclude/>
        </member>
        <member name="M:Tools.error.ToString">
            <exclude/>
        </member>
        <member name="T:Tools.recoveredError">
            <exclude/>
        </member>
        <member name="M:Tools.recoveredError.#ctor(Tools.Parser,Tools.ParseStackEntry)">
            <exclude/>
        </member>
        <member name="M:Tools.recoveredError.ToString">
            <exclude/>
        </member>
        <member name="M:Tools.recoveredError.ConcreteSyntaxTree">
            <exclude/>
        </member>
        <member name="M:Tools.recoveredError.Print">
            <exclude/>
        </member>
        <member name="T:Tools.EOF">
            <exclude/>
        </member>
        <member name="M:Tools.EOF.#ctor(Tools.SymbolsGen)">
            <exclude/>
        </member>
        <member name="M:Tools.EOF.#ctor(Tools.Lexer)">
            <exclude/>
        </member>
        <member name="P:Tools.EOF.yyname">
            <exclude/>
        </member>
        <member name="P:Tools.EOF.yynum">
            <exclude/>
        </member>
        <member name="M:Tools.EOF.Serialise(System.Object,Tools.Serialiser)">
            <exclude/>
        </member>
        <member name="T:Tools.Null">
            <exclude/>
        </member>
        <member name="M:Tools.Null.#ctor(Tools.Lexer,System.String)">
            <exclude/>
        </member>
        <member name="M:Tools.Null.#ctor(Tools.Parser,System.String)">
            <exclude/>
        </member>
        <member name="P:Tools.Null.yyname">
            <exclude/>
        </member>
        <member name="T:Tools.SCreator">
            <exclude/>
        </member>
        <member name="T:Tools.Sfactory">
            <exclude/>
        </member>
        <member name="M:Tools.Sfactory.create(System.String,Tools.Parser)">
            <exclude/>
        </member>
        <member name="M:Tools.Sfactory.#ctor(Tools.YyParser,System.String,Tools.SCreator)">
            <exclude/>
        </member>
        <member name="T:Tools.Serialiser">
            <exclude/>
        </member>
        <member name="M:Tools.Serialiser.VersionCheck">
            <exclude/>
        </member>
        <member name="M:Tools.Serialiser.#ctor(System.IO.TextWriter)">
            <exclude/>
        </member>
        <member name="M:Tools.Serialiser.#ctor(System.Int32[])">
            <exclude/>
        </member>
        <member name="P:Tools.Serialiser.Encode">
            <exclude/>
        </member>
        <member name="M:Tools.Serialiser._Write(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Tools.Serialiser._Read">
            <exclude/>
        </member>
        <member name="M:Tools.Serialiser.Serialise(System.Object)">
            <exclude/>
        </member>
        <member name="M:Tools.Serialiser.Deserialise">
            <exclude/>
        </member>
        <member name="T:ObjectList">
            <exclude/>
        </member>
        <member name="M:ObjectList.#ctor">
            <exclude/>
        </member>
        <member name="M:ObjectList.Add(System.Object)">
            <exclude/>
        </member>
        <member name="M:ObjectList.Push(System.Object)">
            <exclude/>
        </member>
        <member name="M:ObjectList.Pop">
            <exclude/>
        </member>
        <member name="P:ObjectList.Top">
            <exclude/>
        </member>
        <member name="P:ObjectList.Count">
            <exclude/>
        </member>
        <member name="P:ObjectList.Item(System.Int32)">
            <exclude/>
        </member>
        <member name="T:ObjectList.OListEnumerator">
            <exclude/>
        </member>
        <member name="P:ObjectList.OListEnumerator.Current">
            <exclude/>
        </member>
        <member name="M:ObjectList.OListEnumerator.#ctor(ObjectList)">
            <exclude/>
        </member>
        <member name="M:ObjectList.OListEnumerator.MoveNext">
            <exclude/>
        </member>
        <member name="M:ObjectList.OListEnumerator.Reset">
            <exclude/>
        </member>
        <member name="M:ObjectList.GetEnumerator">
            <exclude/>
        </member>
    </members>
</doc>
